{"ast":null,"code":"/*! @azure/msal-common v6.3.0 2022-05-02 */\n'use strict';\n\nimport { Separators, CacheAccountType, CacheType, Constants } from '../../utils/Constants.js';\nimport { buildClientInfo } from '../../account/ClientInfo.js';\nimport { StringUtils } from '../../utils/StringUtils.js';\nimport { ClientAuthError } from '../../error/ClientAuthError.js';\nimport { AuthorityType } from '../../authority/AuthorityType.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Type that defines required and optional parameters for an Account field (based on universal cache schema implemented by all MSALs).\r\n *\r\n * Key : Value Schema\r\n *\r\n * Key: <home_account_id>-<environment>-<realm*>\r\n *\r\n * Value Schema:\r\n * {\r\n *      homeAccountId: home account identifier for the auth scheme,\r\n *      environment: entity that issued the token, represented as a full host\r\n *      realm: Full tenant or organizational identifier that the account belongs to\r\n *      localAccountId: Original tenant-specific accountID, usually used for legacy cases\r\n *      username: primary username that represents the user, usually corresponds to preferred_username in the v2 endpt\r\n *      authorityType: Accounts authority type as a string\r\n *      name: Full name for the account, including given name and family name,\r\n *      clientInfo: Full base64 encoded client info received from ESTS\r\n *      lastModificationTime: last time this entity was modified in the cache\r\n *      lastModificationApp:\r\n *      oboAssertion: access token passed in as part of OBO request\r\n *      idTokenClaims: Object containing claims parsed from ID token\r\n *      nativeAccountId: Account identifier on the native device\r\n * }\r\n */\n\nvar AccountEntity =\n/** @class */\nfunction () {\n  function AccountEntity() {}\n  /**\r\n   * Generate Account Id key component as per the schema: <home_account_id>-<environment>\r\n   */\n\n\n  AccountEntity.prototype.generateAccountId = function () {\n    var accountId = [this.homeAccountId, this.environment];\n    return accountId.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n  };\n  /**\r\n   * Generate Account Cache Key as per the schema: <home_account_id>-<environment>-<realm*>\r\n   */\n\n\n  AccountEntity.prototype.generateAccountKey = function () {\n    return AccountEntity.generateAccountCacheKey({\n      homeAccountId: this.homeAccountId,\n      environment: this.environment,\n      tenantId: this.realm,\n      username: this.username,\n      localAccountId: this.localAccountId\n    });\n  };\n  /**\r\n   * returns the type of the cache (in this case account)\r\n   */\n\n\n  AccountEntity.prototype.generateType = function () {\n    switch (this.authorityType) {\n      case CacheAccountType.ADFS_ACCOUNT_TYPE:\n        return CacheType.ADFS;\n\n      case CacheAccountType.MSAV1_ACCOUNT_TYPE:\n        return CacheType.MSA;\n\n      case CacheAccountType.MSSTS_ACCOUNT_TYPE:\n        return CacheType.MSSTS;\n\n      case CacheAccountType.GENERIC_ACCOUNT_TYPE:\n        return CacheType.GENERIC;\n\n      default:\n        {\n          throw ClientAuthError.createUnexpectedAccountTypeError();\n        }\n    }\n  };\n  /**\r\n   * Returns the AccountInfo interface for this account.\r\n   */\n\n\n  AccountEntity.prototype.getAccountInfo = function () {\n    return {\n      homeAccountId: this.homeAccountId,\n      environment: this.environment,\n      tenantId: this.realm,\n      username: this.username,\n      localAccountId: this.localAccountId,\n      name: this.name,\n      idTokenClaims: this.idTokenClaims,\n      nativeAccountId: this.nativeAccountId\n    };\n  };\n  /**\r\n   * Generates account key from interface\r\n   * @param accountInterface\r\n   */\n\n\n  AccountEntity.generateAccountCacheKey = function (accountInterface) {\n    var accountKey = [accountInterface.homeAccountId, accountInterface.environment || Constants.EMPTY_STRING, accountInterface.tenantId || Constants.EMPTY_STRING];\n    return accountKey.join(Separators.CACHE_KEY_SEPARATOR).toLowerCase();\n  };\n  /**\r\n   * Build Account cache from IdToken, clientInfo and authority/policy. Associated with AAD.\r\n   * @param clientInfo\r\n   * @param authority\r\n   * @param idToken\r\n   * @param policy\r\n   */\n\n\n  AccountEntity.createAccount = function (clientInfo, homeAccountId, idToken, authority, oboAssertion, cloudGraphHostName, msGraphHost, environment, nativeAccountId) {\n    var _a, _b, _c, _d, _e, _f;\n\n    var account = new AccountEntity();\n    account.authorityType = CacheAccountType.MSSTS_ACCOUNT_TYPE;\n    account.clientInfo = clientInfo;\n    account.homeAccountId = homeAccountId;\n    account.nativeAccountId = nativeAccountId;\n    var env = environment || authority && authority.getPreferredCache();\n\n    if (!env) {\n      throw ClientAuthError.createInvalidCacheEnvironmentError();\n    }\n\n    account.environment = env; // non AAD scenarios can have empty realm\n\n    account.realm = ((_a = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _a === void 0 ? void 0 : _a.tid) || Constants.EMPTY_STRING;\n    account.oboAssertion = oboAssertion;\n\n    if (idToken) {\n      account.idTokenClaims = idToken.claims; // How do you account for MSA CID here?\n\n      account.localAccountId = ((_b = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _b === void 0 ? void 0 : _b.oid) || ((_c = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _c === void 0 ? void 0 : _c.sub) || Constants.EMPTY_STRING;\n      /*\r\n       * In B2C scenarios the emails claim is used instead of preferred_username and it is an array. In most cases it will contain a single email.\r\n       * This field should not be relied upon if a custom policy is configured to return more than 1 email.\r\n       */\n\n      account.username = ((_d = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _d === void 0 ? void 0 : _d.preferred_username) || (((_e = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _e === void 0 ? void 0 : _e.emails) ? idToken.claims.emails[0] : Constants.EMPTY_STRING);\n      account.name = (_f = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _f === void 0 ? void 0 : _f.name;\n    }\n\n    account.cloudGraphHostName = cloudGraphHostName;\n    account.msGraphHost = msGraphHost;\n    return account;\n  };\n  /**\r\n   * Builds non-AAD/ADFS account.\r\n   * @param authority\r\n   * @param idToken\r\n   */\n\n\n  AccountEntity.createGenericAccount = function (homeAccountId, idToken, authority, oboAssertion, cloudGraphHostName, msGraphHost, environment) {\n    var _a, _b, _c, _d;\n\n    var account = new AccountEntity();\n    account.authorityType = authority && authority.authorityType === AuthorityType.Adfs ? CacheAccountType.ADFS_ACCOUNT_TYPE : CacheAccountType.GENERIC_ACCOUNT_TYPE;\n    account.homeAccountId = homeAccountId; // non AAD scenarios can have empty realm\n\n    account.realm = Constants.EMPTY_STRING;\n    account.oboAssertion = oboAssertion;\n    var env = environment || authority && authority.getPreferredCache();\n\n    if (!env) {\n      throw ClientAuthError.createInvalidCacheEnvironmentError();\n    }\n\n    if (idToken) {\n      // How do you account for MSA CID here?\n      account.localAccountId = ((_a = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _a === void 0 ? void 0 : _a.oid) || ((_b = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _b === void 0 ? void 0 : _b.sub) || Constants.EMPTY_STRING; // upn claim for most ADFS scenarios\n\n      account.username = ((_c = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _c === void 0 ? void 0 : _c.upn) || Constants.EMPTY_STRING;\n      account.name = ((_d = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _d === void 0 ? void 0 : _d.name) || Constants.EMPTY_STRING;\n      account.idTokenClaims = idToken === null || idToken === void 0 ? void 0 : idToken.claims;\n    }\n\n    account.environment = env;\n    account.cloudGraphHostName = cloudGraphHostName;\n    account.msGraphHost = msGraphHost;\n    /*\r\n     * add uniqueName to claims\r\n     * account.name = idToken.claims.uniqueName;\r\n     */\n\n    return account;\n  };\n  /**\r\n   * Generate HomeAccountId from server response\r\n   * @param serverClientInfo\r\n   * @param authType\r\n   */\n\n\n  AccountEntity.generateHomeAccountId = function (serverClientInfo, authType, logger, cryptoObj, idToken) {\n    var _a;\n\n    var accountId = ((_a = idToken === null || idToken === void 0 ? void 0 : idToken.claims) === null || _a === void 0 ? void 0 : _a.sub) ? idToken.claims.sub : Constants.EMPTY_STRING; // since ADFS does not have tid and does not set client_info\n\n    if (authType === AuthorityType.Adfs) {\n      return accountId;\n    } // for cases where there is clientInfo\n\n\n    if (serverClientInfo) {\n      try {\n        var clientInfo = buildClientInfo(serverClientInfo, cryptoObj);\n\n        if (!StringUtils.isEmpty(clientInfo.uid) && !StringUtils.isEmpty(clientInfo.utid)) {\n          return \"\" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid;\n        }\n      } catch (e) {}\n    } // default to \"sub\" claim\n\n\n    logger.verbose(\"No client info in response\");\n    return accountId;\n  };\n  /**\r\n   * Validates an entity: checks for all expected params\r\n   * @param entity\r\n   */\n\n\n  AccountEntity.isAccountEntity = function (entity) {\n    if (!entity) {\n      return false;\n    }\n\n    return entity.hasOwnProperty(\"homeAccountId\") && entity.hasOwnProperty(\"environment\") && entity.hasOwnProperty(\"realm\") && entity.hasOwnProperty(\"localAccountId\") && entity.hasOwnProperty(\"username\") && entity.hasOwnProperty(\"authorityType\");\n  };\n  /**\r\n   * Helper function to determine whether 2 accountInfo objects represent the same account\r\n   * @param accountA\r\n   * @param accountB\r\n   * @param compareClaims - If set to true idTokenClaims will also be compared to determine account equality\r\n   */\n\n\n  AccountEntity.accountInfoIsEqual = function (accountA, accountB, compareClaims) {\n    if (!accountA || !accountB) {\n      return false;\n    }\n\n    var claimsMatch = true; // default to true so as to not fail comparison below if compareClaims: false\n\n    if (compareClaims) {\n      var accountAClaims = accountA.idTokenClaims || {};\n      var accountBClaims = accountB.idTokenClaims || {}; // issued at timestamp and nonce are expected to change each time a new id token is acquired\n\n      claimsMatch = accountAClaims.iat === accountBClaims.iat && accountAClaims.nonce === accountBClaims.nonce;\n    }\n\n    return accountA.homeAccountId === accountB.homeAccountId && accountA.localAccountId === accountB.localAccountId && accountA.username === accountB.username && accountA.tenantId === accountB.tenantId && accountA.environment === accountB.environment && accountA.nativeAccountId === accountB.nativeAccountId && claimsMatch;\n  };\n\n  return AccountEntity;\n}();\n\nexport { AccountEntity }; //# sourceMappingURL=AccountEntity.js.map","map":null,"metadata":{},"sourceType":"module"}