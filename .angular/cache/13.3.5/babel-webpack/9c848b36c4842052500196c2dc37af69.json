{"ast":null,"code":"/*! @azure/msal-browser v2.24.0 2022-05-02 */\n'use strict';\n\nimport { __extends, __awaiter, __generator, __assign } from '../_virtual/_tslib.js';\nimport { TimeUtils, PerformanceEvents, AuthenticationScheme, PopTokenGenerator, AccountEntity, Constants, AuthorityType, ScopeSet, AuthToken, PromptValue, UrlString, OIDC_DEFAULT_SCOPES } from '@azure/msal-common';\nimport { BaseInteractionClient } from './BaseInteractionClient.js';\nimport { TemporaryCacheKeys, NativeExtensionMethod, ApiId } from '../utils/BrowserConstants.js';\nimport { NativeAuthError } from '../error/NativeAuthError.js';\nimport { BrowserAuthError } from '../error/BrowserAuthError.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nvar NativeInteractionClient =\n/** @class */\nfunction (_super) {\n  __extends(NativeInteractionClient, _super);\n\n  function NativeInteractionClient(config, browserStorage, browserCrypto, logger, eventHandler, navigationClient, apiId, performanceClient, provider, accountId, correlationId) {\n    var _this = _super.call(this, config, browserStorage, browserCrypto, logger, eventHandler, navigationClient, performanceClient, provider, correlationId) || this;\n\n    _this.apiId = apiId;\n    _this.accountId = accountId;\n    _this.nativeMessageHandler = provider;\n    return _this;\n  }\n  /**\r\n   * Acquire token from native platform via browser extension\r\n   * @param request\r\n   */\n\n\n  NativeInteractionClient.prototype.acquireToken = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var nativeATMeasurement, nativeRequest, messageBody, reqTimestamp, response, validatedResponse;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.trace(\"NativeInteractionClient - acquireToken called.\");\n            nativeATMeasurement = this.performanceClient.startMeasurement(PerformanceEvents.NativeInteractionClientAcquireToken, request.correlationId);\n            return [4\n            /*yield*/\n            , this.initializeNativeRequest(request)];\n\n          case 1:\n            nativeRequest = _a.sent();\n            messageBody = {\n              method: NativeExtensionMethod.GetToken,\n              request: nativeRequest\n            };\n            reqTimestamp = TimeUtils.nowSeconds();\n            return [4\n            /*yield*/\n            , this.nativeMessageHandler.sendMessage(messageBody)];\n\n          case 2:\n            response = _a.sent();\n            validatedResponse = this.validateNativeResponse(response);\n            return [2\n            /*return*/\n            , this.handleNativeResponse(validatedResponse, nativeRequest, reqTimestamp).then(function (result) {\n              nativeATMeasurement.endMeasurement({\n                success: true,\n                isNativeBroker: true\n              });\n              return result;\n            }).catch(function (error) {\n              nativeATMeasurement.endMeasurement({\n                success: false,\n                isNativeBroker: true\n              });\n              throw error;\n            })];\n        }\n      });\n    });\n  };\n  /**\r\n   * Acquires a token from native platform then redirects to the redirectUri instead of returning the response\r\n   * @param request\r\n   */\n\n\n  NativeInteractionClient.prototype.acquireTokenRedirect = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var nativeRequest, messageBody, response, e_1, navigationOptions, redirectUri;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.trace(\"NativeInteractionClient - acquireTokenRedirect called.\");\n            return [4\n            /*yield*/\n            , this.initializeNativeRequest(request)];\n\n          case 1:\n            nativeRequest = _a.sent();\n            messageBody = {\n              method: NativeExtensionMethod.GetToken,\n              request: nativeRequest\n            };\n            _a.label = 2;\n\n          case 2:\n            _a.trys.push([2, 4,, 5]);\n\n            return [4\n            /*yield*/\n            , this.nativeMessageHandler.sendMessage(messageBody)];\n\n          case 3:\n            response = _a.sent();\n            this.validateNativeResponse(response);\n            return [3\n            /*break*/\n            , 5];\n\n          case 4:\n            e_1 = _a.sent(); // Only throw fatal errors here to allow application to fallback to regular redirect. Otherwise proceed and the error will be thrown in handleRedirectPromise\n\n            if (e_1 instanceof NativeAuthError && e_1.isFatal()) {\n              throw e_1;\n            }\n\n            return [3\n            /*break*/\n            , 5];\n\n          case 5:\n            this.browserStorage.setTemporaryCache(TemporaryCacheKeys.NATIVE_REQUEST, JSON.stringify(nativeRequest), true);\n            navigationOptions = {\n              apiId: ApiId.acquireTokenRedirect,\n              timeout: this.config.system.redirectNavigationTimeout,\n              noHistory: false\n            };\n            redirectUri = this.config.auth.navigateToLoginRequestUrl ? window.location.href : this.getRedirectUri(request.redirectUri);\n            return [4\n            /*yield*/\n            , this.navigationClient.navigateExternal(redirectUri, navigationOptions)];\n\n          case 6:\n            _a.sent(); // Need to treat this as external to ensure handleRedirectPromise is run again\n\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * If the previous page called native platform for a token using redirect APIs, send the same request again and return the response\r\n   */\n\n\n  NativeInteractionClient.prototype.handleRedirectPromise = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var cachedRequest, messageBody, reqTimestamp, response, result, e_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.trace(\"NativeInteractionClient - handleRedirectPromise called.\");\n\n            if (!this.browserStorage.isInteractionInProgress(true)) {\n              this.logger.info(\"handleRedirectPromise called but there is no interaction in progress, returning null.\");\n              return [2\n              /*return*/\n              , null];\n            }\n\n            cachedRequest = this.browserStorage.getCachedNativeRequest();\n\n            if (!cachedRequest) {\n              this.logger.verbose(\"NativeInteractionClient - handleRedirectPromise called but there is no cached request, returning null.\");\n              return [2\n              /*return*/\n              , null];\n            }\n\n            this.browserStorage.removeItem(this.browserStorage.generateCacheKey(TemporaryCacheKeys.NATIVE_REQUEST));\n            messageBody = {\n              method: NativeExtensionMethod.GetToken,\n              request: cachedRequest\n            };\n            reqTimestamp = TimeUtils.nowSeconds();\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            this.logger.verbose(\"NativeInteractionClient - handleRedirectPromise sending message to native broker.\");\n            return [4\n            /*yield*/\n            , this.nativeMessageHandler.sendMessage(messageBody)];\n\n          case 2:\n            response = _a.sent();\n            this.validateNativeResponse(response);\n            result = this.handleNativeResponse(response, cachedRequest, reqTimestamp);\n            this.browserStorage.setInteractionInProgress(false);\n            return [2\n            /*return*/\n            , result];\n\n          case 3:\n            e_2 = _a.sent();\n            this.browserStorage.setInteractionInProgress(false);\n            throw e_2;\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Logout from native platform via browser extension\r\n   * @param request\r\n   */\n\n\n  NativeInteractionClient.prototype.logout = function () {\n    this.logger.trace(\"NativeInteractionClient - logout called.\");\n    return Promise.reject(\"Logout not implemented yet\");\n  };\n  /**\r\n   * Transform response from native platform into AuthenticationResult object which will be returned to the end user\r\n   * @param response\r\n   * @param request\r\n   * @param reqTimestamp\r\n   */\n\n\n  NativeInteractionClient.prototype.handleNativeResponse = function (response, request, reqTimestamp) {\n    return __awaiter(this, void 0, void 0, function () {\n      var idTokenObj, authority, authorityPreferredCache, homeAccountIdentifier, accountEntity, responseScopes, accountProperties, uid, tid, responseAccessToken, responseTokenType, _a, popTokenGenerator, shrParameters, result;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            this.logger.trace(\"NativeInteractionClient - handleNativeResponse called.\");\n\n            if (response.account.id !== request.accountId) {\n              // User switch in native broker prompt is not supported. All users must first sign in through web flow to ensure server state is in sync\n              throw NativeAuthError.createUserSwitchError();\n            }\n\n            idTokenObj = new AuthToken(response.id_token || Constants.EMPTY_STRING, this.browserCrypto);\n            return [4\n            /*yield*/\n            , this.getDiscoveredAuthority(request.authority)];\n\n          case 1:\n            authority = _b.sent();\n            authorityPreferredCache = authority.getPreferredCache();\n            homeAccountIdentifier = AccountEntity.generateHomeAccountId(response.client_info || Constants.EMPTY_STRING, AuthorityType.Default, this.logger, this.browserCrypto, idTokenObj);\n            accountEntity = AccountEntity.createAccount(response.client_info, homeAccountIdentifier, idTokenObj, undefined, undefined, undefined, undefined, authorityPreferredCache, response.account.id);\n            this.browserStorage.setAccount(accountEntity);\n            responseScopes = response.scopes ? ScopeSet.fromString(response.scopes) : ScopeSet.fromString(request.scopes);\n            accountProperties = response.account.properties || {};\n            uid = accountProperties[\"UID\"] || idTokenObj.claims.oid || idTokenObj.claims.sub || Constants.EMPTY_STRING;\n            tid = accountProperties[\"TenantId\"] || idTokenObj.claims.tid || Constants.EMPTY_STRING;\n            responseTokenType = AuthenticationScheme.BEARER;\n            _a = request.token_type;\n\n            switch (_a) {\n              case AuthenticationScheme.POP:\n                return [3\n                /*break*/\n                , 2];\n            }\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 2:\n            // Set the token type to POP in the response\n            responseTokenType = AuthenticationScheme.POP; // Check if native layer returned an SHR token\n\n            if (response.shr) {\n              this.logger.trace(\"handleNativeServerResponse: SHR is enabled in native layer\");\n              responseAccessToken = response.shr;\n              return [3\n              /*break*/\n              , 5];\n            }\n\n            popTokenGenerator = new PopTokenGenerator(this.browserCrypto);\n            shrParameters = {\n              resourceRequestMethod: request.resourceRequestMethod,\n              resourceRequestUri: request.resourceRequestUri,\n              shrClaims: request.shrClaims,\n              shrNonce: request.shrNonce\n            };\n            return [4\n            /*yield*/\n            , popTokenGenerator.signPopToken(response.access_token, shrParameters)];\n\n          case 3:\n            responseAccessToken = _b.sent();\n            return [3\n            /*break*/\n            , 5];\n\n          case 4:\n            {\n              responseAccessToken = response.access_token;\n            }\n            _b.label = 5;\n\n          case 5:\n            result = {\n              authority: authority.canonicalAuthority,\n              uniqueId: uid,\n              tenantId: tid,\n              scopes: responseScopes.asArray(),\n              account: accountEntity.getAccountInfo(),\n              idToken: response.id_token,\n              idTokenClaims: idTokenObj.claims,\n              accessToken: responseAccessToken,\n              fromCache: false,\n              expiresOn: new Date(Number(reqTimestamp + response.expires_in) * 1000),\n              tokenType: responseTokenType,\n              correlationId: this.correlationId,\n              state: response.state,\n              fromNativeBroker: true\n            }; // Remove any existing cached tokens for this account\n\n            this.browserStorage.removeAccountContext(accountEntity).catch(function (e) {\n              _this.logger.error(\"Error occurred while removing account context from browser storage. \" + e);\n            });\n            return [2\n            /*return*/\n            , result];\n        }\n      });\n    });\n  };\n  /**\r\n   * Validates native platform response before processing\r\n   * @param response\r\n   */\n\n\n  NativeInteractionClient.prototype.validateNativeResponse = function (response) {\n    if (response.hasOwnProperty(\"access_token\") && response.hasOwnProperty(\"id_token\") && response.hasOwnProperty(\"client_info\") && response.hasOwnProperty(\"account\") && response.hasOwnProperty(\"scopes\") && response.hasOwnProperty(\"expires_in\")) {\n      return response;\n    } else {\n      throw NativeAuthError.createUnexpectedError(\"Response missing expected properties.\");\n    }\n  };\n  /**\r\n   * Translates developer provided request object into NativeRequest object\r\n   * @param request\r\n   */\n\n\n  NativeInteractionClient.prototype.initializeNativeRequest = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var authority, canonicalAuthority, scopes, scopeSet, instanceAware, validatedRequest, shrParameters, popTokenGenerator, cnf, _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            this.logger.trace(\"NativeInteractionClient - initializeNativeRequest called\");\n            authority = request.authority || this.config.auth.authority;\n            canonicalAuthority = new UrlString(authority);\n            canonicalAuthority.validateAsUri();\n            scopes = request && request.scopes || [];\n            scopeSet = new ScopeSet(scopes);\n            scopeSet.appendScopes(OIDC_DEFAULT_SCOPES);\n\n            if (request.prompt) {\n              switch (request.prompt) {\n                case PromptValue.NONE:\n                case PromptValue.CONSENT:\n                  this.logger.trace(\"initializeNativeRequest: prompt is compatible with native flow\");\n                  break;\n\n                default:\n                  this.logger.trace(\"initializeNativeRequest: prompt = \" + request.prompt + \" is not compatible with native flow\");\n                  throw BrowserAuthError.createNativePromptParameterNotSupportedError();\n              }\n            }\n\n            instanceAware = !!(request.extraQueryParameters && request.extraQueryParameters.instance_aware);\n            validatedRequest = __assign(__assign({}, request), {\n              accountId: this.accountId,\n              clientId: this.config.auth.clientId,\n              authority: canonicalAuthority.urlString,\n              scopes: scopeSet.printScopes(),\n              redirectUri: this.getRedirectUri(request.redirectUri),\n              correlationId: this.correlationId,\n              instance_aware: instanceAware,\n              token_type: request.authenticationScheme,\n              windowTitleSubstring: document.title,\n              extraParameters: __assign(__assign({}, request.extraQueryParameters), request.tokenQueryParameters),\n              extendedExpiryToken: false // Make this configurable?\n\n            });\n            if (!(request.authenticationScheme === AuthenticationScheme.POP)) return [3\n            /*break*/\n            , 3];\n            shrParameters = {\n              resourceRequestUri: request.resourceRequestUri,\n              resourceRequestMethod: request.resourceRequestMethod,\n              shrClaims: request.shrClaims,\n              shrNonce: request.shrNonce\n            };\n            popTokenGenerator = new PopTokenGenerator(this.browserCrypto);\n            return [4\n            /*yield*/\n            , popTokenGenerator.generateCnf(shrParameters)];\n\n          case 1:\n            cnf = _b.sent(); // to reduce the URL length, it is recommended to send the hash of the req_cnf instead of the whole string\n\n            _a = validatedRequest;\n            return [4\n            /*yield*/\n            , popTokenGenerator.generateCnfHash(cnf)];\n\n          case 2:\n            // to reduce the URL length, it is recommended to send the hash of the req_cnf instead of the whole string\n            _a.req_cnf = _b.sent();\n            _b.label = 3;\n\n          case 3:\n            if (this.apiId === ApiId.ssoSilent || this.apiId === ApiId.acquireTokenSilent_silentFlow) {\n              validatedRequest.prompt = PromptValue.NONE;\n            }\n\n            return [2\n            /*return*/\n            , validatedRequest];\n        }\n      });\n    });\n  };\n\n  return NativeInteractionClient;\n}(BaseInteractionClient);\n\nexport { NativeInteractionClient }; //# sourceMappingURL=NativeInteractionClient.js.map","map":null,"metadata":{},"sourceType":"module"}