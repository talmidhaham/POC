{"ast":null,"code":"/*! @azure/msal-common v6.3.0 2022-05-02 */\n'use strict';\n\nimport { __extends, __awaiter, __generator, __assign, __spreadArrays } from '../_virtual/_tslib.js';\nimport { BaseClient } from './BaseClient.js';\nimport { RequestParameterBuilder } from '../request/RequestParameterBuilder.js';\nimport { Separators, AADServerParamKeys, AuthenticationScheme, GrantType, PromptValue } from '../utils/Constants.js';\nimport { ResponseHandler } from '../response/ResponseHandler.js';\nimport { StringUtils } from '../utils/StringUtils.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { UrlString } from '../url/UrlString.js';\nimport { PopTokenGenerator } from '../crypto/PopTokenGenerator.js';\nimport { TimeUtils } from '../utils/TimeUtils.js';\nimport { buildClientInfo, buildClientInfoFromHomeAccountId } from '../account/ClientInfo.js';\nimport { CcsCredentialType } from '../account/CcsCredential.js';\nimport { ClientConfigurationError } from '../error/ClientConfigurationError.js';\nimport { RequestValidator } from '../request/RequestValidator.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Oauth2.0 Authorization Code client\r\n */\n\nvar AuthorizationCodeClient =\n/** @class */\nfunction (_super) {\n  __extends(AuthorizationCodeClient, _super);\n\n  function AuthorizationCodeClient(configuration) {\n    var _this = _super.call(this, configuration) || this; // Flag to indicate if client is for hybrid spa auth code redemption\n\n\n    _this.includeRedirectUri = true;\n    return _this;\n  }\n  /**\r\n   * Creates the URL of the authorization request letting the user input credentials and consent to the\r\n   * application. The URL target the /authorize endpoint of the authority configured in the\r\n   * application object.\r\n   *\r\n   * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI\r\n   * sent in the request and should contain an authorization code, which can then be used to acquire tokens via\r\n   * acquireToken(AuthorizationCodeRequest)\r\n   * @param request\r\n   */\n\n\n  AuthorizationCodeClient.prototype.getAuthCodeUrl = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var queryString;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.createAuthCodeUrlQueryString(request)];\n\n          case 1:\n            queryString = _a.sent();\n            return [2\n            /*return*/\n            , UrlString.appendQueryString(this.authority.authorizationEndpoint, queryString)];\n        }\n      });\n    });\n  };\n  /**\r\n   * API to acquire a token in exchange of 'authorization_code` acquired by the user in the first leg of the\r\n   * authorization_code_grant\r\n   * @param request\r\n   */\n\n\n  AuthorizationCodeClient.prototype.acquireToken = function (request, authCodePayload) {\n    return __awaiter(this, void 0, void 0, function () {\n      var reqTimestamp, response, responseHandler;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.info(\"in acquireToken call\");\n\n            if (!request || StringUtils.isEmpty(request.code)) {\n              throw ClientAuthError.createTokenRequestCannotBeMadeError();\n            }\n\n            reqTimestamp = TimeUtils.nowSeconds();\n            return [4\n            /*yield*/\n            , this.executeTokenRequest(this.authority, request)];\n\n          case 1:\n            response = _a.sent();\n            responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin); // Validate response. This function throws a server error if an error is returned by the server.\n\n            responseHandler.validateTokenResponse(response.body);\n            return [4\n            /*yield*/\n            , responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request, authCodePayload)];\n\n          case 2:\n            return [2\n            /*return*/\n            , _a.sent()];\n        }\n      });\n    });\n  };\n  /**\r\n   * Handles the hash fragment response from public client code request. Returns a code response used by\r\n   * the client to exchange for a token in acquireToken.\r\n   * @param hashFragment\r\n   */\n\n\n  AuthorizationCodeClient.prototype.handleFragmentResponse = function (hashFragment, cachedState) {\n    // Handle responses.\n    var responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, null, null); // Deserialize hash fragment response parameters.\n\n    var hashUrlString = new UrlString(hashFragment); // Deserialize hash fragment response parameters.\n\n    var serverParams = UrlString.getDeserializedHash(hashUrlString.getHash()); // Get code response\n\n    responseHandler.validateServerAuthorizationCodeResponse(serverParams, cachedState, this.cryptoUtils); // throw when there is no auth code in the response\n\n    if (!serverParams.code) {\n      throw ClientAuthError.createNoAuthCodeInServerResponseError();\n    }\n\n    return __assign(__assign({}, serverParams), {\n      // Code param is optional in ServerAuthorizationCodeResponse but required in AuthorizationCodePaylod\n      code: serverParams.code\n    });\n  };\n  /**\r\n   * Used to log out the current user, and redirect the user to the postLogoutRedirectUri.\r\n   * Default behaviour is to redirect the user to `window.location.href`.\r\n   * @param authorityUri\r\n   */\n\n\n  AuthorizationCodeClient.prototype.getLogoutUri = function (logoutRequest) {\n    // Throw error if logoutRequest is null/undefined\n    if (!logoutRequest) {\n      throw ClientConfigurationError.createEmptyLogoutRequestError();\n    }\n\n    var queryString = this.createLogoutUrlQueryString(logoutRequest); // Construct logout URI.\n\n    return UrlString.appendQueryString(this.authority.endSessionEndpoint, queryString);\n  };\n  /**\r\n   * Executes POST request to token endpoint\r\n   * @param authority\r\n   * @param request\r\n   */\n\n\n  AuthorizationCodeClient.prototype.executeTokenRequest = function (authority, request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var thumbprint, requestBody, queryParameters, ccsCredential, clientInfo, headers, endpoint;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            thumbprint = {\n              clientId: this.config.authOptions.clientId,\n              authority: authority.canonicalAuthority,\n              scopes: request.scopes,\n              claims: request.claims,\n              authenticationScheme: request.authenticationScheme,\n              resourceRequestMethod: request.resourceRequestMethod,\n              resourceRequestUri: request.resourceRequestUri,\n              shrClaims: request.shrClaims,\n              sshKid: request.sshKid\n            };\n            return [4\n            /*yield*/\n            , this.createTokenRequestBody(request)];\n\n          case 1:\n            requestBody = _a.sent();\n            queryParameters = this.createTokenQueryParameters(request);\n            ccsCredential = undefined;\n\n            if (request.clientInfo) {\n              try {\n                clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils);\n                ccsCredential = {\n                  credential: \"\" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid,\n                  type: CcsCredentialType.HOME_ACCOUNT_ID\n                };\n              } catch (e) {\n                this.logger.verbose(\"Could not parse client info for CCS Header: \" + e);\n              }\n            }\n\n            headers = this.createTokenRequestHeaders(ccsCredential || request.ccsCredential);\n            endpoint = StringUtils.isEmpty(queryParameters) ? authority.tokenEndpoint : authority.tokenEndpoint + \"?\" + queryParameters;\n            return [2\n            /*return*/\n            , this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint)];\n        }\n      });\n    });\n  };\n  /**\r\n   * Creates query string for the /token request\r\n   * @param request\r\n   */\n\n\n  AuthorizationCodeClient.prototype.createTokenQueryParameters = function (request) {\n    var parameterBuilder = new RequestParameterBuilder();\n\n    if (request.tokenQueryParameters) {\n      parameterBuilder.addExtraQueryParameters(request.tokenQueryParameters);\n    }\n\n    return parameterBuilder.createQueryString();\n  };\n  /**\r\n   * Generates a map for all the params to be sent to the service\r\n   * @param request\r\n   */\n\n\n  AuthorizationCodeClient.prototype.createTokenRequestBody = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var parameterBuilder, clientAssertion, popTokenGenerator, cnfString, correlationId, ccsCred, clientInfo, clientInfo;\n\n      var _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            parameterBuilder = new RequestParameterBuilder();\n            parameterBuilder.addClientId(this.config.authOptions.clientId);\n            /*\r\n             * For hybrid spa flow, there will be a code but no verifier\r\n             * In this scenario, don't include redirect uri as auth code will not be bound to redirect URI\r\n             */\n\n            if (!this.includeRedirectUri) {\n              // Just validate\n              RequestValidator.validateRedirectUri(request.redirectUri);\n            } else {\n              // Validate and include redirect uri\n              parameterBuilder.addRedirectUri(request.redirectUri);\n            } // Add scope array, parameter builder will add default scopes and dedupe\n\n\n            parameterBuilder.addScopes(request.scopes); // add code: user set, not validated\n\n            parameterBuilder.addAuthorizationCode(request.code); // Add library metadata\n\n            parameterBuilder.addLibraryInfo(this.config.libraryInfo);\n            parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);\n            parameterBuilder.addThrottling();\n\n            if (this.serverTelemetryManager) {\n              parameterBuilder.addServerTelemetry(this.serverTelemetryManager);\n            } // add code_verifier if passed\n\n\n            if (request.codeVerifier) {\n              parameterBuilder.addCodeVerifier(request.codeVerifier);\n            }\n\n            if (this.config.clientCredentials.clientSecret) {\n              parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);\n            }\n\n            if (this.config.clientCredentials.clientAssertion) {\n              clientAssertion = this.config.clientCredentials.clientAssertion;\n              parameterBuilder.addClientAssertion(clientAssertion.assertion);\n              parameterBuilder.addClientAssertionType(clientAssertion.assertionType);\n            }\n\n            parameterBuilder.addGrantType(GrantType.AUTHORIZATION_CODE_GRANT);\n            parameterBuilder.addClientInfo();\n            if (!(request.authenticationScheme === AuthenticationScheme.POP)) return [3\n            /*break*/\n            , 2];\n            popTokenGenerator = new PopTokenGenerator(this.cryptoUtils);\n            return [4\n            /*yield*/\n            , popTokenGenerator.generateCnf(request)];\n\n          case 1:\n            cnfString = _b.sent();\n            parameterBuilder.addPopToken(cnfString);\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            if (request.authenticationScheme === AuthenticationScheme.SSH) {\n              if (request.sshJwk) {\n                parameterBuilder.addSshJwk(request.sshJwk);\n              } else {\n                throw ClientConfigurationError.createMissingSshJwkError();\n              }\n            }\n\n            _b.label = 3;\n\n          case 3:\n            correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\n            parameterBuilder.addCorrelationId(correlationId);\n\n            if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\n              parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\n            }\n\n            ccsCred = undefined;\n\n            if (request.clientInfo) {\n              try {\n                clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils);\n                ccsCred = {\n                  credential: \"\" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid,\n                  type: CcsCredentialType.HOME_ACCOUNT_ID\n                };\n              } catch (e) {\n                this.logger.verbose(\"Could not parse client info for CCS Header: \" + e);\n              }\n            } else {\n              ccsCred = request.ccsCredential;\n            } // Adds these as parameters in the request instead of headers to prevent CORS preflight request\n\n\n            if (this.config.systemOptions.preventCorsPreflight && ccsCred) {\n              switch (ccsCred.type) {\n                case CcsCredentialType.HOME_ACCOUNT_ID:\n                  try {\n                    clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);\n                    parameterBuilder.addCcsOid(clientInfo);\n                  } catch (e) {\n                    this.logger.verbose(\"Could not parse home account ID for CCS Header: \" + e);\n                  }\n\n                  break;\n\n                case CcsCredentialType.UPN:\n                  parameterBuilder.addCcsUpn(ccsCred.credential);\n                  break;\n              }\n            }\n\n            if (request.tokenBodyParameters) {\n              parameterBuilder.addExtraQueryParameters(request.tokenBodyParameters);\n            } // Add hybrid spa parameters if not already provided\n\n\n            if (request.enableSpaAuthorizationCode && (!request.tokenBodyParameters || !request.tokenBodyParameters[AADServerParamKeys.RETURN_SPA_CODE])) {\n              parameterBuilder.addExtraQueryParameters((_a = {}, _a[AADServerParamKeys.RETURN_SPA_CODE] = \"1\", _a));\n            }\n\n            return [2\n            /*return*/\n            , parameterBuilder.createQueryString()];\n        }\n      });\n    });\n  };\n  /**\r\n   * This API validates the `AuthorizationCodeUrlRequest` and creates a URL\r\n   * @param request\r\n   */\n\n\n  AuthorizationCodeClient.prototype.createAuthCodeUrlQueryString = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var parameterBuilder, requestScopes, correlationId, accountSid, clientInfo, clientInfo, popTokenGenerator, cnf, cnfHash;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            parameterBuilder = new RequestParameterBuilder();\n            parameterBuilder.addClientId(this.config.authOptions.clientId);\n            requestScopes = __spreadArrays(request.scopes || [], request.extraScopesToConsent || []);\n            parameterBuilder.addScopes(requestScopes); // validate the redirectUri (to be a non null value)\n\n            parameterBuilder.addRedirectUri(request.redirectUri);\n            correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\n            parameterBuilder.addCorrelationId(correlationId); // add response_mode. If not passed in it defaults to query.\n\n            parameterBuilder.addResponseMode(request.responseMode); // add response_type = code\n\n            parameterBuilder.addResponseTypeCode(); // add library info parameters\n\n            parameterBuilder.addLibraryInfo(this.config.libraryInfo);\n            parameterBuilder.addApplicationTelemetry(this.config.telemetry.application); // add client_info=1\n\n            parameterBuilder.addClientInfo();\n\n            if (request.codeChallenge && request.codeChallengeMethod) {\n              parameterBuilder.addCodeChallengeParams(request.codeChallenge, request.codeChallengeMethod);\n            }\n\n            if (request.prompt) {\n              parameterBuilder.addPrompt(request.prompt);\n            }\n\n            if (request.domainHint) {\n              parameterBuilder.addDomainHint(request.domainHint);\n            } // Add sid or loginHint with preference for sid -> loginHint -> username of AccountInfo object\n\n\n            if (request.prompt !== PromptValue.SELECT_ACCOUNT) {\n              // AAD will throw if prompt=select_account is passed with an account hint\n              if (request.sid && request.prompt === PromptValue.NONE) {\n                // SessionID is only used in silent calls\n                this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is none, adding sid from request\");\n                parameterBuilder.addSid(request.sid);\n              } else if (request.account) {\n                accountSid = this.extractAccountSid(request.account); // If account and loginHint are provided, we will check account first for sid before adding loginHint\n\n                if (accountSid && request.prompt === PromptValue.NONE) {\n                  // SessionId is only used in silent calls\n                  this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is none, adding sid from account\");\n                  parameterBuilder.addSid(accountSid);\n\n                  try {\n                    clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n                    parameterBuilder.addCcsOid(clientInfo);\n                  } catch (e) {\n                    this.logger.verbose(\"Could not parse home account ID for CCS Header: \" + e);\n                  }\n                } else if (request.loginHint) {\n                  this.logger.verbose(\"createAuthCodeUrlQueryString: Adding login_hint from request\");\n                  parameterBuilder.addLoginHint(request.loginHint);\n                  parameterBuilder.addCcsUpn(request.loginHint);\n                } else if (request.account.username) {\n                  // Fallback to account username if provided\n                  this.logger.verbose(\"createAuthCodeUrlQueryString: Adding login_hint from account\");\n                  parameterBuilder.addLoginHint(request.account.username);\n\n                  try {\n                    clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n                    parameterBuilder.addCcsOid(clientInfo);\n                  } catch (e) {\n                    this.logger.verbose(\"Could not parse home account ID for CCS Header: \" + e);\n                  }\n                }\n              } else if (request.loginHint) {\n                this.logger.verbose(\"createAuthCodeUrlQueryString: No account, adding login_hint from request\");\n                parameterBuilder.addLoginHint(request.loginHint);\n                parameterBuilder.addCcsUpn(request.loginHint);\n              }\n            } else {\n              this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints\");\n            }\n\n            if (request.nonce) {\n              parameterBuilder.addNonce(request.nonce);\n            }\n\n            if (request.state) {\n              parameterBuilder.addState(request.state);\n            }\n\n            if (!StringUtils.isEmpty(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\n              parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\n            }\n\n            if (request.extraQueryParameters) {\n              parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);\n            }\n\n            if (!request.nativeBroker) return [3\n            /*break*/\n            , 3]; // signal ests that this is a WAM call\n\n            parameterBuilder.addNativeBroker();\n            if (!(request.authenticationScheme === AuthenticationScheme.POP)) return [3\n            /*break*/\n            , 3];\n            popTokenGenerator = new PopTokenGenerator(this.cryptoUtils);\n            return [4\n            /*yield*/\n            , popTokenGenerator.generateCnf(request)];\n\n          case 1:\n            cnf = _a.sent();\n            return [4\n            /*yield*/\n            , popTokenGenerator.generateCnfHash(cnf)];\n\n          case 2:\n            cnfHash = _a.sent();\n            parameterBuilder.addPopToken(cnfHash);\n            _a.label = 3;\n\n          case 3:\n            return [2\n            /*return*/\n            , parameterBuilder.createQueryString()];\n        }\n      });\n    });\n  };\n  /**\r\n   * This API validates the `EndSessionRequest` and creates a URL\r\n   * @param request\r\n   */\n\n\n  AuthorizationCodeClient.prototype.createLogoutUrlQueryString = function (request) {\n    var parameterBuilder = new RequestParameterBuilder();\n\n    if (request.postLogoutRedirectUri) {\n      parameterBuilder.addPostLogoutRedirectUri(request.postLogoutRedirectUri);\n    }\n\n    if (request.correlationId) {\n      parameterBuilder.addCorrelationId(request.correlationId);\n    }\n\n    if (request.idTokenHint) {\n      parameterBuilder.addIdTokenHint(request.idTokenHint);\n    }\n\n    if (request.state) {\n      parameterBuilder.addState(request.state);\n    }\n\n    if (request.logoutHint) {\n      parameterBuilder.addLogoutHint(request.logoutHint);\n    }\n\n    if (request.extraQueryParameters) {\n      parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);\n    }\n\n    return parameterBuilder.createQueryString();\n  };\n  /**\r\n   * Helper to get sid from account. Returns null if idTokenClaims are not present or sid is not present.\r\n   * @param account\r\n   */\n\n\n  AuthorizationCodeClient.prototype.extractAccountSid = function (account) {\n    if (account.idTokenClaims) {\n      var tokenClaims = account.idTokenClaims;\n      return tokenClaims.sid || null;\n    }\n\n    return null;\n  };\n\n  return AuthorizationCodeClient;\n}(BaseClient);\n\nexport { AuthorizationCodeClient }; //# sourceMappingURL=AuthorizationCodeClient.js.map","map":null,"metadata":{},"sourceType":"module"}