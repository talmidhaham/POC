{"ast":null,"code":"/*! @azure/msal-browser v2.24.0 2022-05-02 */\n'use strict';\n\nimport { __awaiter, __generator } from '../../_virtual/_tslib.js';\nimport { NativeConstants, NativeExtensionMethod } from '../../utils/BrowserConstants.js';\nimport { AuthError, AuthenticationScheme } from '@azure/msal-common';\nimport { NativeAuthError } from '../../error/NativeAuthError.js';\nimport { BrowserAuthError } from '../../error/BrowserAuthError.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nvar NativeMessageHandler =\n/** @class */\nfunction () {\n  function NativeMessageHandler(logger, handshakeTimeoutMs, extensionId) {\n    this.logger = logger;\n    this.handshakeTimeoutMs = handshakeTimeoutMs;\n    this.extensionId = extensionId;\n    this.resolvers = new Map(); // Used for non-handshake messages\n\n    this.handshakeResolvers = new Map(); // Used for handshake messages\n\n    this.responseId = 0;\n    this.messageChannel = new MessageChannel();\n    this.windowListener = this.onWindowMessage.bind(this); // Window event callback doesn't have access to 'this' unless it's bound\n  }\n  /**\r\n   * Sends a given message to the extension and resolves with the extension response\r\n   * @param body\r\n   */\n\n\n  NativeMessageHandler.prototype.sendMessage = function (body) {\n    return __awaiter(this, void 0, void 0, function () {\n      var req;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        this.logger.trace(\"NativeMessageHandler - sendMessage called.\");\n        req = {\n          channel: NativeConstants.CHANNEL_ID,\n          extensionId: this.extensionId,\n          responseId: this.responseId++,\n          body: body\n        };\n        this.logger.trace(\"NativeMessageHandler - Sending request to browser extension\");\n        this.logger.tracePii(\"NativeMessageHandler - Sending request to browser extension: \" + JSON.stringify(req));\n        this.messageChannel.port1.postMessage(req);\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          _this.resolvers.set(req.responseId, {\n            resolve: resolve,\n            reject: reject\n          });\n        })];\n      });\n    });\n  };\n  /**\r\n   * Returns an instance of the MessageHandler that has successfully established a connection with an extension\r\n   * @param logger\r\n   * @param handshakeTimeoutMs\r\n   */\n\n\n  NativeMessageHandler.createProvider = function (logger, handshakeTimeoutMs) {\n    return __awaiter(this, void 0, void 0, function () {\n      var preferredProvider, backupProvider;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            logger.trace(\"NativeMessageHandler - createProvider called.\");\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 5]);\n\n            preferredProvider = new NativeMessageHandler(logger, handshakeTimeoutMs, NativeConstants.PREFERRED_EXTENSION_ID);\n            return [4\n            /*yield*/\n            , preferredProvider.sendHandshakeRequest()];\n\n          case 2:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , preferredProvider];\n\n          case 3:\n            _a.sent();\n\n            backupProvider = new NativeMessageHandler(logger, handshakeTimeoutMs);\n            return [4\n            /*yield*/\n            , backupProvider.sendHandshakeRequest()];\n\n          case 4:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , backupProvider];\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Send handshake request helper.\r\n   */\n\n\n  NativeMessageHandler.prototype.sendHandshakeRequest = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var req;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        this.logger.trace(\"NativeMessageHandler - sendHandshakeRequest called.\"); // Register this event listener before sending handshake\n\n        window.addEventListener(\"message\", this.windowListener, false); // false is important, because content script message processing should work first\n\n        req = {\n          channel: NativeConstants.CHANNEL_ID,\n          extensionId: this.extensionId,\n          responseId: this.responseId++,\n          body: {\n            method: NativeExtensionMethod.HandshakeRequest\n          }\n        };\n\n        this.messageChannel.port1.onmessage = function (event) {\n          _this.onChannelMessage(event);\n        };\n\n        window.postMessage(req, window.origin, [this.messageChannel.port2]);\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          _this.handshakeResolvers.set(req.responseId, {\n            resolve: resolve,\n            reject: reject\n          });\n\n          _this.timeoutId = window.setTimeout(function () {\n            /*\r\n             * Throw an error if neither HandshakeResponse nor original Handshake request are received in a reasonable timeframe.\r\n             * This typically suggests an event handler stopped propagation of the Handshake request but did not respond to it on the MessageChannel port\r\n             */\n            window.removeEventListener(\"message\", _this.windowListener, false);\n\n            _this.messageChannel.port1.close();\n\n            _this.messageChannel.port2.close();\n\n            reject(BrowserAuthError.createNativeHandshakeTimeoutError());\n\n            _this.handshakeResolvers.delete(req.responseId);\n          }, _this.handshakeTimeoutMs); // Use a reasonable timeout in milliseconds here\n        })];\n      });\n    });\n  };\n  /**\r\n   * Invoked when a message is posted to the window. If a handshake request is received it means the extension is not installed.\r\n   * @param event\r\n   */\n\n\n  NativeMessageHandler.prototype.onWindowMessage = function (event) {\n    this.logger.trace(\"NativeMessageHandler - onWindowMessage called\"); // We only accept messages from ourselves\n\n    if (event.source !== window) {\n      return;\n    }\n\n    var request = event.data;\n\n    if (!request.channel || request.channel !== NativeConstants.CHANNEL_ID) {\n      return;\n    }\n\n    if (request.extensionId && request.extensionId !== this.extensionId) {\n      return;\n    }\n\n    if (request.body.method === NativeExtensionMethod.HandshakeRequest) {\n      // If we receive this message back it means no extension intercepted the request, meaning no extension supporting handshake protocol is installed\n      this.logger.verbose(request.extensionId ? \"Extension with id: \" + request.extensionId + \" not installed\" : \"No extension installed\");\n      clearTimeout(this.timeoutId);\n      this.messageChannel.port1.close();\n      this.messageChannel.port2.close();\n      window.removeEventListener(\"message\", this.windowListener, false);\n      var handshakeResolver = this.handshakeResolvers.get(request.responseId);\n\n      if (handshakeResolver) {\n        handshakeResolver.reject(BrowserAuthError.createNativeExtensionNotInstalledError());\n      }\n    }\n  };\n  /**\r\n   * Invoked when a message is received from the extension on the MessageChannel port\r\n   * @param event\r\n   */\n\n\n  NativeMessageHandler.prototype.onChannelMessage = function (event) {\n    this.logger.trace(\"NativeMessageHandler - onChannelMessage called.\");\n    var request = event.data;\n    var resolver = this.resolvers.get(request.responseId);\n    var handshakeResolver = this.handshakeResolvers.get(request.responseId);\n\n    try {\n      var method = request.body.method;\n\n      if (method === NativeExtensionMethod.Response) {\n        if (!resolver) {\n          return;\n        }\n\n        var response = request.body.response;\n        this.logger.trace(\"NativeMessageHandler - Received response from browser extension\");\n        this.logger.tracePii(\"NativeMessageHandler - Received response from browser extension: \" + JSON.stringify(response));\n\n        if (response.status !== \"Success\") {\n          resolver.reject(NativeAuthError.createError(response.code, response.description, response.ext));\n        } else if (response.result) {\n          if (response.result[\"code\"] && response.result[\"description\"]) {\n            resolver.reject(NativeAuthError.createError(response.result[\"code\"], response.result[\"description\"], response.result[\"ext\"]));\n          } else {\n            resolver.resolve(response.result);\n          }\n        } else {\n          throw AuthError.createUnexpectedError(\"Event does not contain result.\");\n        }\n\n        this.resolvers.delete(request.responseId);\n      } else if (method === NativeExtensionMethod.HandshakeResponse) {\n        if (!handshakeResolver) {\n          return;\n        }\n\n        clearTimeout(this.timeoutId); // Clear setTimeout\n\n        window.removeEventListener(\"message\", this.windowListener, false); // Remove 'No extension' listener\n\n        this.extensionId = request.extensionId;\n        this.logger.verbose(\"NativeMessageHandler - Received HandshakeResponse from extension: \" + this.extensionId);\n        handshakeResolver.resolve();\n        this.handshakeResolvers.delete(request.responseId);\n      } // Do nothing if method is not Response or HandshakeResponse\n\n    } catch (err) {\n      this.logger.error(\"Error parsing response from WAM Extension\");\n      this.logger.errorPii(\"Error parsing response from WAM Extension: \" + err.toString());\n      this.logger.errorPii(\"Unable to parse \" + event);\n\n      if (resolver) {\n        resolver.reject(err);\n      } else if (handshakeResolver) {\n        handshakeResolver.reject(err);\n      }\n    }\n  };\n  /**\r\n   * Returns boolean indicating whether or not the request should attempt to use native broker\r\n   * @param logger\r\n   * @param config\r\n   * @param nativeExtensionProvider\r\n   * @param authenticationScheme\r\n   */\n\n\n  NativeMessageHandler.isNativeAvailable = function (config, logger, nativeExtensionProvider, authenticationScheme) {\n    logger.trace(\"isNativeAvailable called\");\n\n    if (!config.system.allowNativeBroker) {\n      logger.trace(\"isNativeAvailable: allowNativeBroker is not enabled, returning false\"); // Developer disabled WAM\n\n      return false;\n    }\n\n    if (!nativeExtensionProvider) {\n      logger.trace(\"isNativeAvailable: WAM extension provider is not initialized, returning false\"); // Extension is not available\n\n      return false;\n    }\n\n    if (authenticationScheme) {\n      switch (authenticationScheme) {\n        case AuthenticationScheme.BEARER:\n        case AuthenticationScheme.POP:\n          logger.trace(\"isNativeAvailable: authenticationScheme is supported, returning true\");\n          return true;\n\n        default:\n          logger.trace(\"isNativeAvailable: authenticationScheme is not supported, returning false\");\n          return false;\n      }\n    }\n\n    return true;\n  };\n\n  return NativeMessageHandler;\n}();\n\nexport { NativeMessageHandler }; //# sourceMappingURL=NativeMessageHandler.js.map","map":null,"metadata":{},"sourceType":"module"}