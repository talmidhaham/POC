{"ast":null,"code":"/*! @azure/msal-common v6.3.0 2022-05-02 */\n'use strict';\n\nimport { __extends, __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { BaseClient } from './BaseClient.js';\nimport { AuthToken } from '../account/AuthToken.js';\nimport { TimeUtils } from '../utils/TimeUtils.js';\nimport { RefreshTokenClient } from './RefreshTokenClient.js';\nimport { ClientAuthError, ClientAuthErrorMessage } from '../error/ClientAuthError.js';\nimport { ClientConfigurationError } from '../error/ClientConfigurationError.js';\nimport { ResponseHandler } from '../response/ResponseHandler.js';\nimport { CacheOutcome } from '../utils/Constants.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nvar SilentFlowClient =\n/** @class */\nfunction (_super) {\n  __extends(SilentFlowClient, _super);\n\n  function SilentFlowClient(configuration) {\n    return _super.call(this, configuration) || this;\n  }\n  /**\r\n   * Retrieves a token from cache if it is still valid, or uses the cached refresh token to renew\r\n   * the given token and returns the renewed token\r\n   * @param request\r\n   */\n\n\n  SilentFlowClient.prototype.acquireToken = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var e_1, refreshTokenClient;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 2,, 3]);\n\n            return [4\n            /*yield*/\n            , this.acquireCachedToken(request)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.sent()];\n\n          case 2:\n            e_1 = _a.sent();\n\n            if (e_1 instanceof ClientAuthError && e_1.errorCode === ClientAuthErrorMessage.tokenRefreshRequired.code) {\n              refreshTokenClient = new RefreshTokenClient(this.config);\n              return [2\n              /*return*/\n              , refreshTokenClient.acquireTokenByRefreshToken(request)];\n            } else {\n              throw e_1;\n            }\n\n          case 3:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Retrieves token from cache or throws an error if it must be refreshed.\r\n   * @param request\r\n   */\n\n\n  SilentFlowClient.prototype.acquireCachedToken = function (request) {\n    var _a, _b, _c, _d;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var environment, cacheRecord;\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            // Cannot renew token if no request object is given.\n            if (!request) {\n              throw ClientConfigurationError.createEmptyTokenRequestError();\n            }\n\n            if (request.forceRefresh) {\n              // Must refresh due to present force_refresh flag.\n              (_a = this.serverTelemetryManager) === null || _a === void 0 ? void 0 : _a.setCacheOutcome(CacheOutcome.FORCE_REFRESH);\n              this.logger.info(\"SilentFlowClient:acquireCachedToken - Skipping cache because forceRefresh is true.\");\n              throw ClientAuthError.createRefreshRequiredError();\n            } // We currently do not support silent flow for account === null use cases; This will be revisited for confidential flow usecases\n\n\n            if (!request.account) {\n              throw ClientAuthError.createNoAccountInSilentRequestError();\n            }\n\n            environment = request.authority || this.authority.getPreferredCache();\n            cacheRecord = this.cacheManager.readCacheRecord(request.account, this.config.authOptions.clientId, request, environment);\n\n            if (!cacheRecord.accessToken) {\n              // Must refresh due to non-existent access_token.\n              (_b = this.serverTelemetryManager) === null || _b === void 0 ? void 0 : _b.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);\n              this.logger.info(\"SilentFlowClient:acquireCachedToken - No access token found in cache for the given properties.\");\n              throw ClientAuthError.createRefreshRequiredError();\n            } else if (TimeUtils.wasClockTurnedBack(cacheRecord.accessToken.cachedAt) || TimeUtils.isTokenExpired(cacheRecord.accessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {\n              // Must refresh due to expired access_token.\n              (_c = this.serverTelemetryManager) === null || _c === void 0 ? void 0 : _c.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);\n              this.logger.info(\"SilentFlowClient:acquireCachedToken - Cached access token is expired or will expire within \" + this.config.systemOptions.tokenRenewalOffsetSeconds + \" seconds.\");\n              throw ClientAuthError.createRefreshRequiredError();\n            } else if (cacheRecord.accessToken.refreshOn && TimeUtils.isTokenExpired(cacheRecord.accessToken.refreshOn, 0)) {\n              // Must refresh due to the refresh_in value.\n              (_d = this.serverTelemetryManager) === null || _d === void 0 ? void 0 : _d.setCacheOutcome(CacheOutcome.REFRESH_CACHED_ACCESS_TOKEN);\n              this.logger.info(\"SilentFlowClient:acquireCachedToken - Cached access token's refreshOn property has been exceeded'.\");\n              throw ClientAuthError.createRefreshRequiredError();\n            }\n\n            if (this.config.serverTelemetryManager) {\n              this.config.serverTelemetryManager.incrementCacheHits();\n            }\n\n            return [4\n            /*yield*/\n            , this.generateResultFromCacheRecord(cacheRecord, request)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _e.sent()];\n        }\n      });\n    });\n  };\n  /**\r\n   * Helper function to build response object from the CacheRecord\r\n   * @param cacheRecord\r\n   */\n\n\n  SilentFlowClient.prototype.generateResultFromCacheRecord = function (cacheRecord, request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var idTokenObj;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (cacheRecord.idToken) {\n              idTokenObj = new AuthToken(cacheRecord.idToken.secret, this.config.cryptoInterface);\n            }\n\n            return [4\n            /*yield*/\n            , ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, cacheRecord, true, request, idTokenObj)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.sent()];\n        }\n      });\n    });\n  };\n\n  return SilentFlowClient;\n}(BaseClient);\n\nexport { SilentFlowClient }; //# sourceMappingURL=SilentFlowClient.js.map","map":null,"metadata":{},"sourceType":"module"}