{"ast":null,"code":"import _get from \"D:\\\\Git\\\\ANGULAR\\\\B2C\\\\POC\\\\2-call-api-b2c\\\\SPA\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\get.js\";\nimport _getPrototypeOf from \"D:\\\\Git\\\\ANGULAR\\\\B2C\\\\POC\\\\2-call-api-b2c\\\\SPA\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\getPrototypeOf.js\";\nimport _inherits from \"D:\\\\Git\\\\ANGULAR\\\\B2C\\\\POC\\\\2-call-api-b2c\\\\SPA\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\inherits.js\";\nimport _createSuper from \"D:\\\\Git\\\\ANGULAR\\\\B2C\\\\POC\\\\2-call-api-b2c\\\\SPA\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createSuper.js\";\nimport _classCallCheck from \"D:\\\\Git\\\\ANGULAR\\\\B2C\\\\POC\\\\2-call-api-b2c\\\\SPA\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"D:\\\\Git\\\\ANGULAR\\\\B2C\\\\POC\\\\2-call-api-b2c\\\\SPA\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport _regeneratorRuntime from \"D:\\\\Git\\\\ANGULAR\\\\B2C\\\\POC\\\\2-call-api-b2c\\\\SPA\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\";\nimport { InjectionToken, Injectable, Inject, VERSION, Component, NgModule } from '@angular/core';\nimport { Location, DOCUMENT, CommonModule } from '@angular/common';\nimport { WrapperSKU, InteractionStatus, EventMessageUtils, InteractionType, BrowserConfigurationAuthError, UrlString, BrowserUtils, StringUtils, NavigationClient } from '@azure/msal-browser';\nimport { from, Subject, BehaviorSubject, of, EMPTY } from 'rxjs';\nimport { Router } from '@angular/router';\nimport { map, concatMap, catchError, switchMap } from 'rxjs/operators';\nimport { __awaiter } from 'tslib';\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@angular/common';\nimport * as ɵngcc2 from '@angular/router';\nvar MSAL_INSTANCE = new InjectionToken(\"MSAL_INSTANCE\");\nvar MSAL_GUARD_CONFIG = new InjectionToken(\"MSAL_GUARD_CONFIG\");\nvar MSAL_INTERCEPTOR_CONFIG = new InjectionToken(\"MSAL_INTERCEPTOR_CONFIG\");\n/* eslint-disable header/header */\n\nvar name = \"@azure/msal-angular\";\nvar version = \"2.3.0\";\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nvar MsalService = /*#__PURE__*/(function () {\n  var MsalService = /*#__PURE__*/function () {\n    function MsalService(instance, location) {\n      _classCallCheck(this, MsalService);\n\n      this.instance = instance;\n      this.location = location;\n      var hash = this.location.path(true).split(\"#\").pop();\n\n      if (hash) {\n        this.redirectHash = \"#\".concat(hash);\n      }\n\n      this.instance.initializeWrapperLibrary(WrapperSKU.Angular, version);\n    }\n\n    _createClass(MsalService, [{\n      key: \"initialize\",\n      value: function initialize() {\n        return from(this.instance.initialize());\n      }\n    }, {\n      key: \"acquireTokenPopup\",\n      value: function acquireTokenPopup(request) {\n        return from(this.instance.acquireTokenPopup(request));\n      }\n    }, {\n      key: \"acquireTokenRedirect\",\n      value: function acquireTokenRedirect(request) {\n        return from(this.instance.acquireTokenRedirect(request));\n      }\n    }, {\n      key: \"acquireTokenSilent\",\n      value: function acquireTokenSilent(silentRequest) {\n        return from(this.instance.acquireTokenSilent(silentRequest));\n      }\n    }, {\n      key: \"handleRedirectObservable\",\n      value: function handleRedirectObservable(hash) {\n        return from(this.instance.handleRedirectPromise(hash || this.redirectHash));\n      }\n    }, {\n      key: \"loginPopup\",\n      value: function loginPopup(request) {\n        return from(this.instance.loginPopup(request));\n      }\n    }, {\n      key: \"loginRedirect\",\n      value: function loginRedirect(request) {\n        return from(this.instance.loginRedirect(request));\n      }\n    }, {\n      key: \"logout\",\n      value: function logout(logoutRequest) {\n        return from(this.instance.logout(logoutRequest));\n      }\n    }, {\n      key: \"logoutRedirect\",\n      value: function logoutRedirect(logoutRequest) {\n        return from(this.instance.logoutRedirect(logoutRequest));\n      }\n    }, {\n      key: \"logoutPopup\",\n      value: function logoutPopup(logoutRequest) {\n        return from(this.instance.logoutPopup(logoutRequest));\n      }\n    }, {\n      key: \"ssoSilent\",\n      value: function ssoSilent(request) {\n        return from(this.instance.ssoSilent(request));\n      }\n      /**\n       * Gets logger for msal-angular.\n       * If no logger set, returns logger instance created with same options as msal-browser\n       */\n\n    }, {\n      key: \"getLogger\",\n      value: function getLogger() {\n        if (!this.logger) {\n          this.logger = this.instance.getLogger().clone(name, version);\n        }\n\n        return this.logger;\n      } // Create a logger instance for msal-angular with the same options as msal-browser\n\n    }, {\n      key: \"setLogger\",\n      value: function setLogger(logger) {\n        this.logger = logger.clone(name, version);\n        this.instance.setLogger(logger);\n      }\n    }]);\n\n    return MsalService;\n  }();\n\n  MsalService.ɵfac = function MsalService_Factory(t) {\n    return new (t || MsalService)(ɵngcc0.ɵɵinject(MSAL_INSTANCE), ɵngcc0.ɵɵinject(ɵngcc1.Location));\n  };\n\n  MsalService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: MsalService,\n    factory: MsalService.ɵfac\n  });\n  return MsalService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\nvar MsalBroadcastService = /*#__PURE__*/(function () {\n  var MsalBroadcastService = /*#__PURE__*/_createClass(function MsalBroadcastService(msalInstance, authService) {\n    var _this = this;\n\n    _classCallCheck(this, MsalBroadcastService);\n\n    this.msalInstance = msalInstance;\n    this.authService = authService;\n    this._msalSubject = new Subject();\n    this.msalSubject$ = this._msalSubject.asObservable(); // InProgress as BehaviorSubject so most recent inProgress state will be available upon subscription\n\n    this._inProgress = new BehaviorSubject(InteractionStatus.Startup);\n    this.inProgress$ = this._inProgress.asObservable();\n    this.msalInstance.addEventCallback(function (message) {\n      _this._msalSubject.next(message);\n\n      var status = EventMessageUtils.getInteractionStatusFromEvent(message, _this._inProgress.value);\n\n      if (status !== null) {\n        _this.authService.getLogger().verbose(\"BroadcastService - \".concat(message.eventType, \" results in setting inProgress from \").concat(_this._inProgress.value, \" to \").concat(status));\n\n        _this._inProgress.next(status);\n      }\n    });\n  });\n\n  MsalBroadcastService.ɵfac = function MsalBroadcastService_Factory(t) {\n    return new (t || MsalBroadcastService)(ɵngcc0.ɵɵinject(MSAL_INSTANCE), ɵngcc0.ɵɵinject(MsalService));\n  };\n\n  MsalBroadcastService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: MsalBroadcastService,\n    factory: MsalBroadcastService.ɵfac\n  });\n  return MsalBroadcastService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\nvar MsalGuard = /*#__PURE__*/(function () {\n  var MsalGuard = /*#__PURE__*/function () {\n    function MsalGuard(msalGuardConfig, msalBroadcastService, authService, location, router) {\n      _classCallCheck(this, MsalGuard);\n\n      this.msalGuardConfig = msalGuardConfig;\n      this.msalBroadcastService = msalBroadcastService;\n      this.authService = authService;\n      this.location = location;\n      this.router = router; // Subscribing so events in MsalGuard will set inProgress$ observable\n\n      this.msalBroadcastService.inProgress$.subscribe();\n    }\n    /**\n     * Parses url string to UrlTree\n     * @param url\n     */\n\n\n    _createClass(MsalGuard, [{\n      key: \"parseUrl\",\n      value: function parseUrl(url) {\n        return this.router.parseUrl(url);\n      }\n      /**\n       * Builds the absolute url for the destination page\n       * @param path Relative path of requested page\n       * @returns Full destination url\n       */\n\n    }, {\n      key: \"getDestinationUrl\",\n      value: function getDestinationUrl(path) {\n        this.authService.getLogger().verbose(\"Guard - getting destination url\"); // Absolute base url for the application (default to origin if base element not present)\n\n        var baseElements = document.getElementsByTagName(\"base\");\n        var baseUrl = this.location.normalize(baseElements.length ? baseElements[0].href : window.location.origin); // Path of page (including hash, if using hash routing)\n\n        var pathUrl = this.location.prepareExternalUrl(path); // Hash location strategy\n\n        if (pathUrl.startsWith(\"#\")) {\n          this.authService.getLogger().verbose(\"Guard - destination by hash routing\");\n          return \"\".concat(baseUrl, \"/\").concat(pathUrl);\n        }\n        /*\n         * If using path location strategy, pathUrl will include the relative portion of the base path (e.g. /base/page).\n         * Since baseUrl also includes /base, can just concatentate baseUrl + path\n         */\n\n\n        return \"\".concat(baseUrl).concat(path);\n      }\n      /**\n       * Interactively prompt the user to login\n       * @param url Path of the requested page\n       */\n\n    }, {\n      key: \"loginInteractively\",\n      value: function loginInteractively(state) {\n        var _this2 = this;\n\n        var authRequest = typeof this.msalGuardConfig.authRequest === \"function\" ? this.msalGuardConfig.authRequest(this.authService, state) : Object.assign({}, this.msalGuardConfig.authRequest);\n\n        if (this.msalGuardConfig.interactionType === InteractionType.Popup) {\n          this.authService.getLogger().verbose(\"Guard - logging in by popup\");\n          return this.authService.loginPopup(authRequest).pipe(map(function (response) {\n            _this2.authService.getLogger().verbose(\"Guard - login by popup successful, can activate, setting active account\");\n\n            _this2.authService.instance.setActiveAccount(response.account);\n\n            return true;\n          }));\n        }\n\n        this.authService.getLogger().verbose(\"Guard - logging in by redirect\");\n        var redirectStartPage = this.getDestinationUrl(state.url);\n        return this.authService.loginRedirect(Object.assign({\n          redirectStartPage: redirectStartPage\n        }, authRequest)).pipe(map(function () {\n          return false;\n        }));\n      }\n      /**\n       * Helper which checks for the correct interaction type, prevents page with Guard to be set as reidrect, and calls handleRedirectObservable\n       * @param state\n       */\n\n    }, {\n      key: \"activateHelper\",\n      value: function activateHelper(state) {\n        var _this3 = this;\n\n        if (this.msalGuardConfig.interactionType !== InteractionType.Popup && this.msalGuardConfig.interactionType !== InteractionType.Redirect) {\n          throw new BrowserConfigurationAuthError(\"invalid_interaction_type\", \"Invalid interaction type provided to MSAL Guard. InteractionType.Popup or InteractionType.Redirect must be provided in the MsalGuardConfiguration\");\n        }\n\n        this.authService.getLogger().verbose(\"MSAL Guard activated\");\n        /*\n         * If a page with MSAL Guard is set as the redirect for acquireTokenSilent,\n         * short-circuit to prevent redirecting or popups.\n         */\n\n        if (typeof window !== \"undefined\") {\n          if (UrlString.hashContainsKnownProperties(window.location.hash) && BrowserUtils.isInIframe() && !this.authService.instance.getConfiguration().system.allowRedirectInIframe) {\n            this.authService.getLogger().warning(\"Guard - redirectUri set to page with MSAL Guard. It is recommended to not set redirectUri to a page that requires authentication.\");\n            return of(false);\n          }\n        } else {\n          this.authService.getLogger().info(\"Guard - window is undefined, MSAL does not support server-side token acquisition\");\n          return of(true);\n        }\n        /**\n         * If a loginFailedRoute is set in the config, set this as the loginFailedRoute\n         */\n\n\n        if (this.msalGuardConfig.loginFailedRoute) {\n          this.loginFailedRoute = this.parseUrl(this.msalGuardConfig.loginFailedRoute);\n        } // Capture current path before it gets changed by handleRedirectObservable\n\n\n        var currentPath = this.location.path(true);\n        return this.authService.handleRedirectObservable().pipe(concatMap(function () {\n          if (!_this3.authService.instance.getAllAccounts().length) {\n            if (state) {\n              _this3.authService.getLogger().verbose(\"Guard - no accounts retrieved, log in required to activate\");\n\n              return _this3.loginInteractively(state);\n            }\n\n            _this3.authService.getLogger().verbose(\"Guard - no accounts retrieved, no state, cannot load\");\n\n            return of(false);\n          }\n\n          _this3.authService.getLogger().verbose(\"Guard - at least 1 account exists, can activate or load\"); // Prevent navigating the app to /#code= or /code=\n\n\n          if (state) {\n            /*\n             * Path routing:\n             * state.url: /#code=...\n             * state.root.fragment: code=...\n             */\n\n            /*\n             * Hash routing:\n             * state.url: /code\n             * state.root.fragment: null\n             */\n            var urlContainsCode = _this3.includesCode(state.url);\n\n            var fragmentContainsCode = !!state.root && !!state.root.fragment && _this3.includesCode(\"#\".concat(state.root.fragment));\n\n            var hashRouting = _this3.location.prepareExternalUrl(state.url).indexOf(\"#\") === 0; // Ensure code parameter is in fragment (and not in query parameter), or that hash hash routing is used\n\n            if (urlContainsCode && (fragmentContainsCode || hashRouting)) {\n              _this3.authService.getLogger().info(\"Guard - Hash contains known code response, stopping navigation.\"); // Path routing (navigate to current path without hash)\n\n\n              if (currentPath.indexOf(\"#\") > -1) {\n                return of(_this3.parseUrl(_this3.location.path()));\n              } // Hash routing (navigate to root path)\n\n\n              return of(_this3.parseUrl(\"\"));\n            }\n          }\n\n          return of(true);\n        }), catchError(function (error) {\n          _this3.authService.getLogger().error(\"Guard - error while logging in, unable to activate\");\n\n          _this3.authService.getLogger().errorPii(\"Guard - error: \".concat(error.message));\n          /**\n           * If a loginFailedRoute is set, checks to see if Angular 10+ is used and state is passed in before returning route\n           * Apps using Angular 9 will receive of(false) in canLoad interface, as it does not support UrlTree return types\n           */\n\n\n          if (_this3.loginFailedRoute && parseInt(VERSION.major, 10) > 9 && state) {\n            _this3.authService.getLogger().verbose(\"Guard - loginFailedRoute set, redirecting\");\n\n            return of(_this3.loginFailedRoute);\n          }\n\n          return of(false);\n        }));\n      }\n    }, {\n      key: \"includesCode\",\n      value: function includesCode(path) {\n        return path.lastIndexOf(\"/code\") > -1 && path.lastIndexOf(\"/code\") === path.length - \"/code\".length || // path.endsWith(\"/code\")\n        path.indexOf(\"#code=\") > -1 || path.indexOf(\"&code=\") > -1;\n      }\n    }, {\n      key: \"canActivate\",\n      value: function canActivate(route, state) {\n        this.authService.getLogger().verbose(\"Guard - canActivate\");\n        return this.activateHelper(state);\n      }\n    }, {\n      key: \"canActivateChild\",\n      value: function canActivateChild(route, state) {\n        this.authService.getLogger().verbose(\"Guard - canActivateChild\");\n        return this.activateHelper(state);\n      }\n    }, {\n      key: \"canLoad\",\n      value: function canLoad() {\n        this.authService.getLogger().verbose(\"Guard - canLoad\"); // @ts-ignore\n\n        return this.activateHelper();\n      }\n    }]);\n\n    return MsalGuard;\n  }();\n\n  MsalGuard.ɵfac = function MsalGuard_Factory(t) {\n    return new (t || MsalGuard)(ɵngcc0.ɵɵinject(MSAL_GUARD_CONFIG), ɵngcc0.ɵɵinject(MsalBroadcastService), ɵngcc0.ɵɵinject(MsalService), ɵngcc0.ɵɵinject(ɵngcc1.Location), ɵngcc0.ɵɵinject(ɵngcc2.Router));\n  };\n\n  MsalGuard.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: MsalGuard,\n    factory: MsalGuard.ɵfac\n  });\n  return MsalGuard;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\nvar MsalInterceptor = /*#__PURE__*/(function () {\n  var MsalInterceptor = /*#__PURE__*/function () {\n    function MsalInterceptor(msalInterceptorConfig, authService, location, // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n    document) {\n      _classCallCheck(this, MsalInterceptor);\n\n      this.msalInterceptorConfig = msalInterceptorConfig;\n      this.authService = authService;\n      this.location = location;\n      this._document = document;\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    _createClass(MsalInterceptor, [{\n      key: \"intercept\",\n      value: function intercept(req, next) {\n        var _this4 = this;\n\n        if (this.msalInterceptorConfig.interactionType !== InteractionType.Popup && this.msalInterceptorConfig.interactionType !== InteractionType.Redirect) {\n          throw new BrowserConfigurationAuthError(\"invalid_interaction_type\", \"Invalid interaction type provided to MSAL Interceptor. InteractionType.Popup, InteractionType.Redirect must be provided in the msalInterceptorConfiguration\");\n        }\n\n        this.authService.getLogger().verbose(\"MSAL Interceptor activated\");\n        var scopes = this.getScopesForEndpoint(req.url, req.method); // If no scopes for endpoint, does not acquire token\n\n        if (!scopes || scopes.length === 0) {\n          this.authService.getLogger().verbose(\"Interceptor - no scopes for endpoint\");\n          return next.handle(req);\n        } // Sets account as active account or first account\n\n\n        var account;\n\n        if (!!this.authService.instance.getActiveAccount()) {\n          this.authService.getLogger().verbose(\"Interceptor - active account selected\");\n          account = this.authService.instance.getActiveAccount();\n        } else {\n          this.authService.getLogger().verbose(\"Interceptor - no active account, fallback to first account\");\n          account = this.authService.instance.getAllAccounts()[0];\n        }\n\n        var authRequest = typeof this.msalInterceptorConfig.authRequest === \"function\" ? this.msalInterceptorConfig.authRequest(this.authService, req, {\n          account: account\n        }) : Object.assign(Object.assign({}, this.msalInterceptorConfig.authRequest), {\n          account: account\n        });\n        this.authService.getLogger().info(\"Interceptor - \".concat(scopes.length, \" scopes found for endpoint\"));\n        this.authService.getLogger().infoPii(\"Interceptor - [\".concat(scopes, \"] scopes found for \").concat(req.url)); // Note: For MSA accounts, include openid scope when calling acquireTokenSilent to return idToken\n\n        return this.authService.acquireTokenSilent(Object.assign(Object.assign({}, authRequest), {\n          scopes: scopes,\n          account: account\n        })).pipe(catchError(function () {\n          _this4.authService.getLogger().error(\"Interceptor - acquireTokenSilent rejected with error. Invoking interaction to resolve.\");\n\n          return _this4.acquireTokenInteractively(authRequest, scopes);\n        }), switchMap(function (result) {\n          if (!result.accessToken) {\n            _this4.authService.getLogger().error(\"Interceptor - acquireTokenSilent resolved with null access token. Known issue with B2C tenants, invoking interaction to resolve.\");\n\n            return _this4.acquireTokenInteractively(authRequest, scopes);\n          }\n\n          return of(result);\n        }), switchMap(function (result) {\n          _this4.authService.getLogger().verbose(\"Interceptor - setting authorization headers\");\n\n          var headers = req.headers.set(\"Authorization\", \"Bearer \".concat(result.accessToken));\n          var requestClone = req.clone({\n            headers: headers\n          });\n          return next.handle(requestClone);\n        }));\n      }\n      /**\n       * Invoke interaction for the given set of scopes\n       * @param authRequest Request\n       * @param scopes Array of scopes for the request\n       * @returns Result from the interactive request\n       */\n\n    }, {\n      key: \"acquireTokenInteractively\",\n      value: function acquireTokenInteractively(authRequest, scopes) {\n        if (this.msalInterceptorConfig.interactionType === InteractionType.Popup) {\n          this.authService.getLogger().verbose(\"Interceptor - error acquiring token silently, acquiring by popup\");\n          return this.authService.acquireTokenPopup(Object.assign(Object.assign({}, authRequest), {\n            scopes: scopes\n          }));\n        }\n\n        this.authService.getLogger().verbose(\"Interceptor - error acquiring token silently, acquiring by redirect\");\n        var redirectStartPage = window.location.href;\n        this.authService.acquireTokenRedirect(Object.assign(Object.assign({}, authRequest), {\n          scopes: scopes,\n          redirectStartPage: redirectStartPage\n        }));\n        return EMPTY;\n      }\n      /**\n       * Looks up the scopes for the given endpoint from the protectedResourceMap\n       * @param endpoint Url of the request\n       * @param httpMethod Http method of the request\n       * @returns Array of scopes, or null if not found\n       *\n       */\n\n    }, {\n      key: \"getScopesForEndpoint\",\n      value: function getScopesForEndpoint(endpoint, httpMethod) {\n        this.authService.getLogger().verbose(\"Interceptor - getting scopes for endpoint\"); // Ensures endpoints and protected resources compared are normalized\n\n        var normalizedEndpoint = this.location.normalize(endpoint);\n        var protectedResourcesArray = Array.from(this.msalInterceptorConfig.protectedResourceMap.keys());\n        var matchingProtectedResources = this.matchResourcesToEndpoint(protectedResourcesArray, normalizedEndpoint); // Check absolute urls of resources first before checking relative to prevent incorrect matching where multiple resources have similar relative urls\n\n        if (matchingProtectedResources.absoluteResources.length > 0) {\n          return this.matchScopesToEndpoint(this.msalInterceptorConfig.protectedResourceMap, matchingProtectedResources.absoluteResources, httpMethod);\n        } else if (matchingProtectedResources.relativeResources.length > 0) {\n          return this.matchScopesToEndpoint(this.msalInterceptorConfig.protectedResourceMap, matchingProtectedResources.relativeResources, httpMethod);\n        }\n\n        return null;\n      }\n      /**\n       * Finds resource endpoints that match request endpoint\n       * @param protectedResourcesEndpoints\n       * @param endpoint\n       * @returns\n       */\n\n    }, {\n      key: \"matchResourcesToEndpoint\",\n      value: function matchResourcesToEndpoint(protectedResourcesEndpoints, endpoint) {\n        var _this5 = this;\n\n        var matchingResources = {\n          absoluteResources: [],\n          relativeResources: []\n        };\n        protectedResourcesEndpoints.forEach(function (key) {\n          // Normalizes and adds resource to matchingResources.absoluteResources if key matches endpoint. StringUtils.matchPattern accounts for wildcards\n          var normalizedKey = _this5.location.normalize(key);\n\n          if (StringUtils.matchPattern(normalizedKey, endpoint)) {\n            matchingResources.absoluteResources.push(key);\n          } // Get url components for relative urls\n\n\n          var absoluteKey = _this5.getAbsoluteUrl(key);\n\n          var keyComponents = new UrlString(absoluteKey).getUrlComponents();\n\n          var absoluteEndpoint = _this5.getAbsoluteUrl(endpoint);\n\n          var endpointComponents = new UrlString(absoluteEndpoint).getUrlComponents(); // Normalized key should include query strings if applicable\n\n          var relativeNormalizedKey = keyComponents.QueryString ? \"\".concat(keyComponents.AbsolutePath, \"?\").concat(keyComponents.QueryString) : _this5.location.normalize(keyComponents.AbsolutePath); // Add resource to matchingResources.relativeResources if same origin, relativeKey matches endpoint, and is not empty\n\n          if (keyComponents.HostNameAndPort === endpointComponents.HostNameAndPort && StringUtils.matchPattern(relativeNormalizedKey, absoluteEndpoint) && relativeNormalizedKey !== \"\" && relativeNormalizedKey !== \"/*\") {\n            matchingResources.relativeResources.push(key);\n          }\n        });\n        return matchingResources;\n      }\n      /**\n       * Transforms relative urls to absolute urls\n       * @param url\n       * @returns\n       */\n\n    }, {\n      key: \"getAbsoluteUrl\",\n      value: function getAbsoluteUrl(url) {\n        var link = this._document.createElement(\"a\");\n\n        link.href = url;\n        return link.href;\n      }\n      /**\n       * Finds scopes from first matching endpoint with HTTP method that matches request\n       * @param protectedResourceMap Protected resource map\n       * @param endpointArray Array of resources that match request endpoint\n       * @param httpMethod Http method of the request\n       * @returns\n       */\n\n    }, {\n      key: \"matchScopesToEndpoint\",\n      value: function matchScopesToEndpoint(protectedResourceMap, endpointArray, httpMethod) {\n        var allMatchedScopes = []; // Check each matched endpoint for matching HttpMethod and scopes\n\n        endpointArray.forEach(function (matchedEndpoint) {\n          var scopesForEndpoint = [];\n          var methodAndScopesArray = protectedResourceMap.get(matchedEndpoint); // Return if resource is unprotected\n\n          if (methodAndScopesArray === null) {\n            allMatchedScopes.push(null);\n            return;\n          }\n\n          methodAndScopesArray.forEach(function (entry) {\n            // Entry is either array of scopes or ProtectedResourceScopes object\n            if (typeof entry === \"string\") {\n              scopesForEndpoint.push(entry);\n            } else {\n              // Ensure methods being compared are normalized\n              var normalizedRequestMethod = httpMethod.toLowerCase();\n              var normalizedResourceMethod = entry.httpMethod.toLowerCase(); // Method in protectedResourceMap matches request http method\n\n              if (normalizedResourceMethod === normalizedRequestMethod) {\n                // Validate if scopes comes null to unprotect the resource in a certain http method \n                if (entry.scopes === null) {\n                  allMatchedScopes.push(null);\n                } else {\n                  entry.scopes.forEach(function (scope) {\n                    scopesForEndpoint.push(scope);\n                  });\n                }\n              }\n            }\n          }); // Only add to all scopes if scopes for endpoint and method is found\n\n          if (scopesForEndpoint.length > 0) {\n            allMatchedScopes.push(scopesForEndpoint);\n          }\n        });\n\n        if (allMatchedScopes.length > 0) {\n          if (allMatchedScopes.length > 1) {\n            this.authService.getLogger().warning(\"Interceptor - More than 1 matching scopes for endpoint found.\");\n          } // Returns scopes for first matching endpoint\n\n\n          return allMatchedScopes[0];\n        }\n\n        return null;\n      }\n    }]);\n\n    return MsalInterceptor;\n  }();\n\n  MsalInterceptor.ɵfac = function MsalInterceptor_Factory(t) {\n    return new (t || MsalInterceptor)(ɵngcc0.ɵɵinject(MSAL_INTERCEPTOR_CONFIG), ɵngcc0.ɵɵinject(MsalService), ɵngcc0.ɵɵinject(ɵngcc1.Location), ɵngcc0.ɵɵinject(DOCUMENT));\n  };\n\n  MsalInterceptor.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: MsalInterceptor,\n    factory: MsalInterceptor.ɵfac\n  });\n  return MsalInterceptor;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\nvar MsalRedirectComponent = /*#__PURE__*/(function () {\n  var MsalRedirectComponent = /*#__PURE__*/function () {\n    function MsalRedirectComponent(authService) {\n      _classCallCheck(this, MsalRedirectComponent);\n\n      this.authService = authService;\n    }\n\n    _createClass(MsalRedirectComponent, [{\n      key: \"ngOnInit\",\n      value: function ngOnInit() {\n        var _this6 = this;\n\n        this.authService.getLogger().verbose(\"MsalRedirectComponent activated\");\n        this.authService.initialize().pipe(concatMap(function () {\n          return _this6.authService.handleRedirectObservable();\n        })).subscribe();\n      }\n    }]);\n\n    return MsalRedirectComponent;\n  }();\n\n  MsalRedirectComponent.ɵfac = function MsalRedirectComponent_Factory(t) {\n    return new (t || MsalRedirectComponent)(ɵngcc0.ɵɵdirectiveInject(MsalService));\n  };\n\n  MsalRedirectComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: MsalRedirectComponent,\n    selectors: [[\"app-redirect\"]],\n    decls: 0,\n    vars: 0,\n    template: function MsalRedirectComponent_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n  return MsalRedirectComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\n\nvar MsalModule = /*#__PURE__*/(function () {\n  var MsalModule = /*#__PURE__*/function () {\n    function MsalModule() {\n      _classCallCheck(this, MsalModule);\n    }\n\n    _createClass(MsalModule, null, [{\n      key: \"forRoot\",\n      value: function forRoot(msalInstance, guardConfig, interceptorConfig) {\n        return {\n          ngModule: MsalModule,\n          providers: [{\n            provide: MSAL_INSTANCE,\n            useValue: msalInstance\n          }, {\n            provide: MSAL_GUARD_CONFIG,\n            useValue: guardConfig\n          }, {\n            provide: MSAL_INTERCEPTOR_CONFIG,\n            useValue: interceptorConfig\n          }, MsalService]\n        };\n      }\n    }]);\n\n    return MsalModule;\n  }();\n\n  MsalModule.ɵfac = function MsalModule_Factory(t) {\n    return new (t || MsalModule)();\n  };\n\n  MsalModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: MsalModule\n  });\n  MsalModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [MsalGuard, MsalBroadcastService],\n    imports: [[CommonModule]]\n  });\n  return MsalModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MsalModule, {\n    declarations: function declarations() {\n      return [MsalRedirectComponent];\n    },\n    imports: function imports() {\n      return [CommonModule];\n    }\n  });\n})();\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Custom navigation used for Angular client-side navigation.\n * See performance doc for details:\n * https://github.com/AzureAD/microsoft-authentication-library-for-js/tree/dev/lib/msal-angular/docs/v2-docs/performance.md\n */\n\n\nvar MsalCustomNavigationClient = /*#__PURE__*/(function () {\n  var MsalCustomNavigationClient = /*#__PURE__*/function (_NavigationClient) {\n    _inherits(MsalCustomNavigationClient, _NavigationClient);\n\n    var _super2 = _createSuper(MsalCustomNavigationClient);\n\n    function MsalCustomNavigationClient(authService, router, location) {\n      var _this7;\n\n      _classCallCheck(this, MsalCustomNavigationClient);\n\n      _this7 = _super2.call(this);\n      _this7.authService = authService;\n      _this7.router = router;\n      _this7.location = location;\n      return _this7;\n    }\n\n    _createClass(MsalCustomNavigationClient, [{\n      key: \"navigateInternal\",\n      value: function navigateInternal(url, options) {\n        var _this8 = this;\n\n        var _super = Object.create(null, {\n          navigateInternal: {\n            get: function get() {\n              return _get(_getPrototypeOf(MsalCustomNavigationClient.prototype), \"navigateInternal\", _this8);\n            }\n          }\n        });\n\n        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n          var urlComponents, newUrl;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  this.authService.getLogger().trace(\"MsalCustomNavigationClient called\");\n                  this.authService.getLogger().verbose(\"MsalCustomNavigationClient - navigating\");\n                  this.authService.getLogger().verbosePii(\"MsalCustomNavigationClient - navigating to url: \".concat(url)); // Prevent hash clearing from causing an issue with Client-side navigation after redirect is handled\n\n                  if (!options.noHistory) {\n                    _context.next = 7;\n                    break;\n                  }\n\n                  return _context.abrupt(\"return\", _super.navigateInternal.call(this, url, options));\n\n                case 7:\n                  // Normalizing newUrl if no query string\n                  urlComponents = new UrlString(url).getUrlComponents();\n                  newUrl = urlComponents.QueryString ? \"\".concat(urlComponents.AbsolutePath, \"?\").concat(urlComponents.QueryString) : this.location.normalize(urlComponents.AbsolutePath);\n                  this.router.navigateByUrl(newUrl, {\n                    replaceUrl: options.noHistory\n                  });\n\n                case 10:\n                  return _context.abrupt(\"return\", Promise.resolve(options.noHistory));\n\n                case 11:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n      }\n    }]);\n\n    return MsalCustomNavigationClient;\n  }(NavigationClient);\n\n  MsalCustomNavigationClient.ɵfac = function MsalCustomNavigationClient_Factory(t) {\n    return new (t || MsalCustomNavigationClient)(ɵngcc0.ɵɵinject(MsalService), ɵngcc0.ɵɵinject(ɵngcc2.Router), ɵngcc0.ɵɵinject(ɵngcc1.Location));\n  };\n\n  MsalCustomNavigationClient.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: MsalCustomNavigationClient,\n    factory: MsalCustomNavigationClient.ɵfac\n  });\n  return MsalCustomNavigationClient;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { MSAL_GUARD_CONFIG, MSAL_INSTANCE, MSAL_INTERCEPTOR_CONFIG, MsalBroadcastService, MsalCustomNavigationClient, MsalGuard, MsalInterceptor, MsalModule, MsalRedirectComponent, MsalService, version }; //# sourceMappingURL=azure-msal-angular.js.map","map":null,"metadata":{},"sourceType":"module"}