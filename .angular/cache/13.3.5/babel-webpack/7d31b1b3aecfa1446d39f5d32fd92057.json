{"ast":null,"code":"/*! @azure/msal-browser v2.24.0 2022-05-02 */\n'use strict';\n\nimport { __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { BrowserAuthError } from '../error/BrowserAuthError.js';\nimport { DB_NAME, DB_VERSION, DB_TABLE_NAME } from '../utils/BrowserConstants.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Storage wrapper for IndexedDB storage in browsers: https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API\r\n */\n\nvar DatabaseStorage =\n/** @class */\nfunction () {\n  function DatabaseStorage() {\n    this.dbName = DB_NAME;\n    this.version = DB_VERSION;\n    this.tableName = DB_TABLE_NAME;\n    this.dbOpen = false;\n  }\n  /**\r\n   * Opens IndexedDB instance.\r\n   */\n\n\n  DatabaseStorage.prototype.open = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          var openDB = window.indexedDB.open(_this.dbName, _this.version);\n          openDB.addEventListener(\"upgradeneeded\", function (e) {\n            var event = e;\n            event.target.result.createObjectStore(_this.tableName);\n          });\n          openDB.addEventListener(\"success\", function (e) {\n            var event = e;\n            _this.db = event.target.result;\n            _this.dbOpen = true;\n            resolve();\n          });\n          openDB.addEventListener(\"error\", function () {\n            return reject(BrowserAuthError.createDatabaseUnavailableError());\n          });\n        })];\n      });\n    });\n  };\n  /**\r\n   * Closes the connection to IndexedDB database when all pending transactions\r\n   * complete.\r\n   */\n\n\n  DatabaseStorage.prototype.closeConnection = function () {\n    var db = this.db;\n\n    if (db && this.dbOpen) {\n      db.close();\n      this.dbOpen = false;\n    }\n  };\n  /**\r\n   * Opens database if it's not already open\r\n   */\n\n\n  DatabaseStorage.prototype.validateDbIsOpen = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!!this.dbOpen) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.open()];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.sent()];\n\n          case 2:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Retrieves item from IndexedDB instance.\r\n   * @param key\r\n   */\n\n\n  DatabaseStorage.prototype.getItem = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.validateDbIsOpen()];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , new Promise(function (resolve, reject) {\n              // TODO: Add timeouts?\n              if (!_this.db) {\n                return reject(BrowserAuthError.createDatabaseNotOpenError());\n              }\n\n              var transaction = _this.db.transaction([_this.tableName], \"readonly\");\n\n              var objectStore = transaction.objectStore(_this.tableName);\n              var dbGet = objectStore.get(key);\n              dbGet.addEventListener(\"success\", function (e) {\n                var event = e;\n\n                _this.closeConnection();\n\n                resolve(event.target.result);\n              });\n              dbGet.addEventListener(\"error\", function (e) {\n                _this.closeConnection();\n\n                reject(e);\n              });\n            })];\n        }\n      });\n    });\n  };\n  /**\r\n   * Adds item to IndexedDB under given key\r\n   * @param key\r\n   * @param payload\r\n   */\n\n\n  DatabaseStorage.prototype.setItem = function (key, payload) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.validateDbIsOpen()];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , new Promise(function (resolve, reject) {\n              // TODO: Add timeouts?\n              if (!_this.db) {\n                return reject(BrowserAuthError.createDatabaseNotOpenError());\n              }\n\n              var transaction = _this.db.transaction([_this.tableName], \"readwrite\");\n\n              var objectStore = transaction.objectStore(_this.tableName);\n              var dbPut = objectStore.put(payload, key);\n              dbPut.addEventListener(\"success\", function () {\n                _this.closeConnection();\n\n                resolve();\n              });\n              dbPut.addEventListener(\"error\", function (e) {\n                _this.closeConnection();\n\n                reject(e);\n              });\n            })];\n        }\n      });\n    });\n  };\n  /**\r\n   * Removes item from IndexedDB under given key\r\n   * @param key\r\n   */\n\n\n  DatabaseStorage.prototype.removeItem = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.validateDbIsOpen()];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , new Promise(function (resolve, reject) {\n              if (!_this.db) {\n                return reject(BrowserAuthError.createDatabaseNotOpenError());\n              }\n\n              var transaction = _this.db.transaction([_this.tableName], \"readwrite\");\n\n              var objectStore = transaction.objectStore(_this.tableName);\n              var dbDelete = objectStore.delete(key);\n              dbDelete.addEventListener(\"success\", function () {\n                _this.closeConnection();\n\n                resolve();\n              });\n              dbDelete.addEventListener(\"error\", function (e) {\n                _this.closeConnection();\n\n                reject(e);\n              });\n            })];\n        }\n      });\n    });\n  };\n  /**\r\n   * Get all the keys from the storage object as an iterable array of strings.\r\n   */\n\n\n  DatabaseStorage.prototype.getKeys = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.validateDbIsOpen()];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , new Promise(function (resolve, reject) {\n              if (!_this.db) {\n                return reject(BrowserAuthError.createDatabaseNotOpenError());\n              }\n\n              var transaction = _this.db.transaction([_this.tableName], \"readonly\");\n\n              var objectStore = transaction.objectStore(_this.tableName);\n              var dbGetKeys = objectStore.getAllKeys();\n              dbGetKeys.addEventListener(\"success\", function (e) {\n                var event = e;\n\n                _this.closeConnection();\n\n                resolve(event.target.result);\n              });\n              dbGetKeys.addEventListener(\"error\", function (e) {\n                _this.closeConnection();\n\n                reject(e);\n              });\n            })];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * Checks whether there is an object under the search key in the object store\r\n   */\n\n\n  DatabaseStorage.prototype.containsKey = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.validateDbIsOpen()];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , new Promise(function (resolve, reject) {\n              if (!_this.db) {\n                return reject(BrowserAuthError.createDatabaseNotOpenError());\n              }\n\n              var transaction = _this.db.transaction([_this.tableName], \"readonly\");\n\n              var objectStore = transaction.objectStore(_this.tableName);\n              var dbContainsKey = objectStore.count(key);\n              dbContainsKey.addEventListener(\"success\", function (e) {\n                var event = e;\n\n                _this.closeConnection();\n\n                resolve(event.target.result === 1);\n              });\n              dbContainsKey.addEventListener(\"error\", function (e) {\n                _this.closeConnection();\n\n                reject(e);\n              });\n            })];\n        }\n      });\n    });\n  };\n  /**\r\n   * Deletes the MSAL database. The database is deleted rather than cleared to make it possible\r\n   * for client applications to downgrade to a previous MSAL version without worrying about forward compatibility issues\r\n   * with IndexedDB database versions.\r\n   */\n\n\n  DatabaseStorage.prototype.deleteDatabase = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var existingDatabases, database;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // Check if database being deleted exists\n            if (this.db && this.dbOpen) {\n              this.closeConnection();\n            }\n\n            return [4\n            /*yield*/\n            , window.indexedDB.databases()];\n\n          case 1:\n            existingDatabases = _a.sent();\n            database = existingDatabases.find(function (database) {\n              return database.name === DB_NAME;\n            }); // If database exists, delete it\n\n            if (database) {\n              return [2\n              /*return*/\n              , new Promise(function (resolve, reject) {\n                var deleteDbRequest = window.indexedDB.deleteDatabase(DB_NAME);\n                deleteDbRequest.addEventListener(\"success\", function () {\n                  return resolve(true);\n                });\n                deleteDbRequest.addEventListener(\"error\", function () {\n                  return reject(false);\n                });\n              })];\n            } // Database doesn't exist, return true\n\n\n            return [2\n            /*return*/\n            , true];\n        }\n      });\n    });\n  };\n\n  return DatabaseStorage;\n}();\n\nexport { DatabaseStorage }; //# sourceMappingURL=DatabaseStorage.js.map","map":null,"metadata":{},"sourceType":"module"}