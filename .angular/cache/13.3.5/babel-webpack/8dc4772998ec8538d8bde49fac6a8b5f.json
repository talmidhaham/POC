{"ast":null,"code":"/*! @azure/msal-common v6.3.0 2022-05-02 */\n'use strict';\n\nimport { __assign } from '../../_virtual/_tslib.js';\nimport { PerformanceEventStatus } from './PerformanceEvent.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nvar PerformanceClient =\n/** @class */\nfunction () {\n  /**\r\n   * Creates an instance of PerformanceClient,\r\n   * an abstract class containing core performance telemetry logic.\r\n   *\r\n   * @constructor\r\n   * @param {string} clientId Client ID of the application\r\n   * @param {string} authority Authority used by the application\r\n   * @param {Logger} logger Logger used by the application\r\n   * @param {string} libraryName Name of the library\r\n   * @param {string} libraryVersion Version of the library\r\n   */\n  function PerformanceClient(clientId, authority, logger, libraryName, libraryVersion, applicationTelemetry) {\n    this.authority = authority;\n    this.libraryName = libraryName;\n    this.libraryVersion = libraryVersion;\n    this.applicationTelemetry = applicationTelemetry;\n    this.clientId = clientId;\n    this.logger = logger;\n    this.callbacks = new Map();\n    this.eventsByCorrelationId = new Map();\n    this.measurementsById = new Map();\n  }\n  /**\r\n   * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.\r\n   *\r\n   * @param {PerformanceEvents} measureName\r\n   * @param {?string} [correlationId]\r\n   * @returns {InProgressPerformanceEvent}\r\n   */\n\n\n  PerformanceClient.prototype.startMeasurement = function (measureName, correlationId) {\n    var _this = this;\n\n    var _a, _b; // Generate a placeholder correlation if the request does not provide one\n\n\n    var eventCorrelationId = correlationId || this.generateId();\n\n    if (!correlationId) {\n      this.logger.info(\"PerformanceClient: No correlation id provided for \" + measureName + \", generating\", eventCorrelationId);\n    }\n\n    this.logger.trace(\"PerformanceClient: Performance measurement started for \" + measureName, eventCorrelationId);\n    var performanceMeasurement = this.startPerformanceMeasuremeant(measureName, eventCorrelationId);\n    performanceMeasurement.startMeasurement();\n    var inProgressEvent = {\n      eventId: this.generateId(),\n      status: PerformanceEventStatus.InProgress,\n      authority: this.authority,\n      libraryName: this.libraryName,\n      libraryVersion: this.libraryVersion,\n      appName: (_a = this.applicationTelemetry) === null || _a === void 0 ? void 0 : _a.appName,\n      appVersion: (_b = this.applicationTelemetry) === null || _b === void 0 ? void 0 : _b.appVersion,\n      clientId: this.clientId,\n      name: measureName,\n      startTimeMs: Date.now(),\n      correlationId: eventCorrelationId\n    }; // Store in progress events so they can be discarded if not ended properly\n\n    this.cacheEventByCorrelationId(inProgressEvent);\n    this.cacheMeasurement(inProgressEvent, performanceMeasurement); // Return the event and functions the caller can use to properly end/flush the measurement\n\n    return {\n      endMeasurement: function endMeasurement(event) {\n        var completedEvent = _this.endMeasurement(__assign(__assign({}, inProgressEvent), event));\n\n        if (completedEvent) {\n          // Cache event so that submeasurements can be added downstream\n          _this.cacheEventByCorrelationId(completedEvent);\n        }\n\n        return completedEvent;\n      },\n      flushMeasurement: function flushMeasurement() {\n        return _this.flushMeasurements(inProgressEvent.name, inProgressEvent.correlationId);\n      },\n      discardMeasurement: function discardMeasurement() {\n        return _this.discardMeasurements(inProgressEvent.correlationId);\n      },\n      measurement: performanceMeasurement,\n      event: inProgressEvent\n    };\n  };\n  /**\r\n   * Stops measuring the performance for an operation. Should only be called directly by PerformanceClient classes,\r\n   * as consumers should instead use the function returned by startMeasurement.\r\n   *\r\n   * @param {PerformanceEvent} event\r\n   * @returns {(PerformanceEvent | null)}\r\n   */\n\n\n  PerformanceClient.prototype.endMeasurement = function (event) {\n    var performanceMeasurement = this.measurementsById.get(event.eventId);\n\n    if (performanceMeasurement) {\n      // Immediately delete so that the same event isnt ended twice\n      this.measurementsById.delete(event.eventId);\n      performanceMeasurement.endMeasurement();\n      var durationMs = performanceMeasurement.flushMeasurement(); // null indicates no measurement was taken (e.g. needed performance APIs not present)\n\n      if (durationMs !== null) {\n        this.logger.trace(\"PerformanceClient: Performance measurement ended for \" + event.name + \": \" + durationMs + \" ms\", event.correlationId);\n\n        var completedEvent = __assign(__assign({\n          // Allow duration to be overwritten when event ends (e.g. testing), but not status\n          durationMs: Math.round(durationMs)\n        }, event), {\n          status: PerformanceEventStatus.Completed\n        });\n\n        return completedEvent;\n      } else {\n        this.logger.trace(\"PerformanceClient: Performance measurement not taken\", event.correlationId);\n      }\n    } else {\n      this.logger.trace(\"PerformanceClient: Measurement not found for \" + event.eventId, event.correlationId);\n    }\n\n    return null;\n  };\n  /**\r\n   * Upserts event into event cache.\r\n   * First key is the correlation id, second key is the event id.\r\n   * Allows for events to be grouped by correlation id,\r\n   * and to easily allow for properties on them to be updated.\r\n   *\r\n   * @private\r\n   * @param {PerformanceEvent} event\r\n   */\n\n\n  PerformanceClient.prototype.cacheEventByCorrelationId = function (event) {\n    var existingEvents = this.eventsByCorrelationId.get(event.correlationId);\n\n    if (existingEvents) {\n      this.logger.trace(\"PerformanceClient: Performance measurement for \" + event.name + \" added/updated\", event.correlationId);\n      existingEvents.set(event.eventId, event);\n    } else {\n      this.logger.trace(\"PerformanceClient: Performance measurement for \" + event.name + \" started\", event.correlationId);\n      this.eventsByCorrelationId.set(event.correlationId, new Map().set(event.eventId, event));\n    }\n  };\n  /**\r\n   * Cache measurements by their id.\r\n   *\r\n   * @private\r\n   * @param {PerformanceEvent} event\r\n   * @param {IPerformanceMeasurement} measurement\r\n   */\n\n\n  PerformanceClient.prototype.cacheMeasurement = function (event, measurement) {\n    this.measurementsById.set(event.eventId, measurement);\n  };\n  /**\r\n   * Gathers and emits performance events for measurements taked for the given top-level API and correlation ID.\r\n   *\r\n   * @param {PerformanceEvents} measureName\r\n   * @param {string} correlationId\r\n   */\n\n\n  PerformanceClient.prototype.flushMeasurements = function (measureName, correlationId) {\n    var _this = this;\n\n    this.logger.trace(\"PerformanceClient: Performance measurements flushed for \" + measureName, correlationId);\n    var eventsForCorrelationId = this.eventsByCorrelationId.get(correlationId);\n\n    if (eventsForCorrelationId) {\n      this.discardMeasurements(correlationId);\n      /*\r\n       * Manually end incomplete submeasurements to ensure there arent orphaned/never ending events.\r\n       * Incomplete submeasurements are likely an instrumentation bug that should be fixed.\r\n       * IE only supports Map.forEach.\r\n       */\n\n      var completedEvents_1 = [];\n      eventsForCorrelationId.forEach(function (event) {\n        if (event.name !== measureName && event.status !== PerformanceEventStatus.Completed) {\n          _this.logger.trace(\"PerformanceClient: Incomplete submeasurement \" + event.name + \" found for \" + measureName, correlationId);\n\n          var completedEvent = _this.endMeasurement(event);\n\n          if (completedEvent) {\n            completedEvents_1.push(completedEvent);\n          }\n        }\n\n        completedEvents_1.push(event);\n      }); // Sort events by start time (earliest first)\n\n      var sortedCompletedEvents = completedEvents_1.sort(function (eventA, eventB) {\n        return eventA.startTimeMs - eventB.startTimeMs;\n      }); // Take completed top level event and add completed submeasurements durations as properties\n\n      var topLevelEvents = sortedCompletedEvents.filter(function (event) {\n        return event.name === measureName && event.status === PerformanceEventStatus.Completed;\n      });\n\n      if (topLevelEvents.length > 0) {\n        /*\r\n         * Only take the first top-level event if there are multiple events with the same correlation id.\r\n         * This greatly simplifies logic for submeasurements.\r\n         */\n        if (topLevelEvents.length > 1) {\n          this.logger.verbose(\"PerformanceClient: Multiple distinct top-level performance events found, using the first\", correlationId);\n        }\n\n        var topLevelEvent = topLevelEvents[0];\n        this.logger.verbose(\"PerformanceClient: Measurement found for \" + measureName, correlationId); // Build event object with top level and sub measurements\n\n        var eventToEmit = sortedCompletedEvents.reduce(function (previous, current) {\n          if (current.name !== measureName) {\n            _this.logger.trace(\"PerformanceClient: Complete submeasurement found for \" + current.name, correlationId); // TODO: Emit additional properties for each subMeasurement\n\n\n            var subMeasurementName = current.name + \"DurationMs\";\n            /*\r\n             * Some code paths, such as resolving an authority, can occur multiple times.\r\n             * Only take the first measurement, since the second could be read from the cache,\r\n             * or due to the same correlation id being used for two distinct requests.\r\n             */\n\n            if (!previous[subMeasurementName]) {\n              previous[subMeasurementName] = current.durationMs;\n            } else {\n              _this.logger.verbose(\"PerformanceClient: Submeasurement for \" + measureName + \" already exists for \" + current.name + \", ignoring\", correlationId);\n            }\n          }\n\n          return previous;\n        }, topLevelEvent);\n        this.emitEvents([eventToEmit], eventToEmit.correlationId);\n      } else {\n        this.logger.verbose(\"PerformanceClient: No completed top-level measurements found for \" + measureName, correlationId);\n      }\n    } else {\n      this.logger.verbose(\"PerformanceClient: No measurements found\", correlationId);\n    }\n  };\n  /**\r\n   * Removes measurements for a given correlation id.\r\n   *\r\n   * @param {string} correlationId\r\n   */\n\n\n  PerformanceClient.prototype.discardMeasurements = function (correlationId) {\n    this.logger.trace(\"PerformanceClient: Performance measurements discarded\", correlationId);\n    this.eventsByCorrelationId.delete(correlationId);\n  };\n  /**\r\n   * Registers a callback function to receive performance events.\r\n   *\r\n   * @param {PerformanceCallbackFunction} callback\r\n   * @returns {string}\r\n   */\n\n\n  PerformanceClient.prototype.addPerformanceCallback = function (callback) {\n    var callbackId = this.generateId();\n    this.callbacks.set(callbackId, callback);\n    this.logger.verbose(\"PerformanceClient: Performance callback registered with id: \" + callbackId);\n    return callbackId;\n  };\n  /**\r\n   * Removes a callback registered with addPerformanceCallback.\r\n   *\r\n   * @param {string} callbackId\r\n   * @returns {boolean}\r\n   */\n\n\n  PerformanceClient.prototype.removePerformanceCallback = function (callbackId) {\n    var result = this.callbacks.delete(callbackId);\n\n    if (result) {\n      this.logger.verbose(\"PerformanceClient: Performance callback \" + callbackId + \" removed.\");\n    } else {\n      this.logger.verbose(\"PerformanceClient: Performance callback \" + callbackId + \" not removed.\");\n    }\n\n    return result;\n  };\n  /**\r\n   * Emits events to all registered callbacks.\r\n   *\r\n   * @param {PerformanceEvent[]} events\r\n   * @param {?string} [correlationId]\r\n   */\n\n\n  PerformanceClient.prototype.emitEvents = function (events, correlationId) {\n    var _this = this;\n\n    this.logger.verbose(\"PerformanceClient: Emitting performance events\", correlationId);\n    this.callbacks.forEach(function (callback, callbackId) {\n      _this.logger.trace(\"PerformanceClient: Emitting event to callback \" + callbackId, correlationId);\n\n      callback.apply(null, [events]);\n    });\n  };\n\n  return PerformanceClient;\n}();\n\nexport { PerformanceClient }; //# sourceMappingURL=PerformanceClient.js.map","map":null,"metadata":{},"sourceType":"module"}