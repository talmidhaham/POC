{"ast":null,"code":"/*! @azure/msal-common v6.3.0 2022-05-02 */\n'use strict';\n\nimport { __awaiter, __generator, __assign } from '../_virtual/_tslib.js';\nimport { AuthToken } from '../account/AuthToken.js';\nimport { TimeUtils } from '../utils/TimeUtils.js';\nimport { UrlString } from '../url/UrlString.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nvar KeyLocation = /*#__PURE__*/(function () {\n  (function (KeyLocation) {\n    KeyLocation[\"SW\"] = \"sw\";\n    KeyLocation[\"UHW\"] = \"uhw\";\n  })(KeyLocation || (KeyLocation = {}));\n\n  return KeyLocation;\n})();\n\nvar PopTokenGenerator =\n/** @class */\nfunction () {\n  function PopTokenGenerator(cryptoUtils) {\n    this.cryptoUtils = cryptoUtils;\n  }\n  /**\r\n   * Generates the req_cnf validated at the RP in the POP protocol for SHR parameters\r\n   * @param request\r\n   * @returns\r\n   */\n\n\n  PopTokenGenerator.prototype.generateCnf = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var reqCnf;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.generateKid(request)];\n\n          case 1:\n            reqCnf = _a.sent();\n            return [2\n            /*return*/\n            , this.cryptoUtils.base64Encode(JSON.stringify(reqCnf))];\n        }\n      });\n    });\n  };\n  /**\r\n   * Generates the hash of the req_cnf\r\n   * @param cnf\r\n   * @returns\r\n   */\n\n\n  PopTokenGenerator.prototype.generateCnfHash = function (cnf) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.cryptoUtils.hashString(cnf)];\n      });\n    });\n  };\n  /**\r\n   * Generates key_id for a SHR token request\r\n   * @param request\r\n   * @returns\r\n   */\n\n\n  PopTokenGenerator.prototype.generateKid = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var kidThumbprint;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.cryptoUtils.getPublicKeyThumbprint(request)];\n\n          case 1:\n            kidThumbprint = _a.sent();\n            return [2\n            /*return*/\n            , {\n              kid: kidThumbprint,\n              xms_ksl: KeyLocation.SW\n            }];\n        }\n      });\n    });\n  };\n  /**\r\n   * Signs the POP access_token with the local generated key-pair\r\n   * @param accessToken\r\n   * @param request\r\n   * @returns\r\n   */\n\n\n  PopTokenGenerator.prototype.signPopToken = function (accessToken, request) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var tokenClaims;\n      return __generator(this, function (_b) {\n        tokenClaims = AuthToken.extractTokenClaims(accessToken, this.cryptoUtils);\n\n        if (!((_a = tokenClaims === null || tokenClaims === void 0 ? void 0 : tokenClaims.cnf) === null || _a === void 0 ? void 0 : _a.kid)) {\n          throw ClientAuthError.createTokenClaimsRequiredError();\n        }\n\n        return [2\n        /*return*/\n        , this.signPayload(accessToken, tokenClaims.cnf.kid, request)];\n      });\n    });\n  };\n  /**\r\n   * Utility function to generate the signed JWT for an access_token\r\n   * @param payload\r\n   * @param kid\r\n   * @param request\r\n   * @param claims\r\n   * @returns\r\n   */\n\n\n  PopTokenGenerator.prototype.signPayload = function (payload, kid, request, claims) {\n    return __awaiter(this, void 0, void 0, function () {\n      var resourceRequestMethod, resourceRequestUri, shrClaims, shrNonce, resourceUrlString, resourceUrlComponents;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            resourceRequestMethod = request.resourceRequestMethod, resourceRequestUri = request.resourceRequestUri, shrClaims = request.shrClaims, shrNonce = request.shrNonce;\n            resourceUrlString = resourceRequestUri ? new UrlString(resourceRequestUri) : undefined;\n            resourceUrlComponents = resourceUrlString === null || resourceUrlString === void 0 ? void 0 : resourceUrlString.getUrlComponents();\n            return [4\n            /*yield*/\n            , this.cryptoUtils.signJwt(__assign({\n              at: payload,\n              ts: TimeUtils.nowSeconds(),\n              m: resourceRequestMethod === null || resourceRequestMethod === void 0 ? void 0 : resourceRequestMethod.toUpperCase(),\n              u: resourceUrlComponents === null || resourceUrlComponents === void 0 ? void 0 : resourceUrlComponents.HostNameAndPort,\n              nonce: shrNonce || this.cryptoUtils.createNewGuid(),\n              p: resourceUrlComponents === null || resourceUrlComponents === void 0 ? void 0 : resourceUrlComponents.AbsolutePath,\n              q: (resourceUrlComponents === null || resourceUrlComponents === void 0 ? void 0 : resourceUrlComponents.QueryString) ? [[], resourceUrlComponents.QueryString] : undefined,\n              client_claims: shrClaims || undefined\n            }, claims), kid, request.correlationId)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.sent()];\n        }\n      });\n    });\n  };\n\n  return PopTokenGenerator;\n}();\n\nexport { PopTokenGenerator }; //# sourceMappingURL=PopTokenGenerator.js.map","map":null,"metadata":{},"sourceType":"module"}